// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package us.ihmc.zed;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static us.ihmc.zed.global.zed.*;


/**
\brief Structure containing data of a detected body/person such as its \ref bounding_box, \ref id and its 3D \ref position.
*/
@Properties(inherit = us.ihmc.zed.ZEDJavaAPIConfig.class)
public class SL_BodyData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public SL_BodyData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public SL_BodyData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SL_BodyData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public SL_BodyData position(long position) {
        return (SL_BodyData)super.position(position);
    }
    @Override public SL_BodyData getPointer(long i) {
        return new SL_BodyData((Pointer)this).offsetAddress(i);
    }

	/**
	\brief Body/person identification number.
	<p>
	It is used as a reference when tracking the body through the frames.
	\note Only available if SL_BodyTrackingParameters.enable_tracking is activated.
	\note Otherwise, it will be set to -1.
	 */
	public native int id(); public native SL_BodyData id(int setter);
	/**
	\brief Unique id to help identify and track AI detections.
    <p>
    It can be either generated externally, or by using \ref sl_generate_unique_id() or left empty.
	*/
	public native @Cast("unsigned char") byte unique_object_id(int i); public native SL_BodyData unique_object_id(int i, byte setter);
	@MemberGetter public native @Cast("unsigned char*") BytePointer unique_object_id();
	/**
	\brief Body/person tracking state.
	 */
	public native @Cast("SL_OBJECT_TRACKING_STATE") int tracking_state(); public native SL_BodyData tracking_state(int setter);
	/**
	\brief Body/person action state.
	 */
	public native @Cast("SL_OBJECT_ACTION_STATE") int action_state(); public native SL_BodyData action_state(int setter);
	/**
	\brief Body/person 3D centroid.
	\note It is defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
	 */
	public native @ByRef @Name("position") SL_Vector3 _position(); public native SL_BodyData _position(SL_Vector3 setter);
	/**
	\brief Body/person 3D velocity.
	\note It is defined in <pre>{@code SL_InitParameters.coordinate_unit / s}</pre> and expressed in SL_RuntimeParameters.reference_frame.
	 */
	public native @ByRef SL_Vector3 velocity(); public native SL_BodyData velocity(SL_Vector3 setter);
	/**
	\brief Covariance matrix of the 3D position.
	\note It is represented by its upper triangular matrix value
	<pre>{@code
			= [p0, p1, p2]
			[p1, p3, p4]
			[p2, p4, p5]
	}</pre>
	where pi is <pre>{@code position_covariance[i]}</pre>
	 */
	public native float position_covariance(int i); public native SL_BodyData position_covariance(int i, float setter);
	@MemberGetter public native FloatPointer position_covariance();
	/**
	\brief Detection confidence value of the body/person.
	<p>
	From 0 to 100, a low value means the body might not be localized perfectly.
	 */
	public native float confidence(); public native SL_BodyData confidence(float setter);

	/**
	\brief Mask defining which pixels which belong to the body/person (in \ref bounding_box_2d and set to 255) and those of the background (set to 0).
	\warning The mask information is only available for tracked bodies (\ref SL_OBJECT_TRACKING_STATE_OK) that have a valid depth.
	\warning Otherwise, the mask will not be initialized.
	*/
	public native IntPointer mask(); public native SL_BodyData mask(IntPointer setter);
	//int* mask; //IntPtr to an sl::Mat object.

	/**
	\brief 2D bounding box of the body/person represented as four 2D points starting at the top left corner and rotation clockwise.
	\note Expressed in pixels on the original image resolution, <pre>{@code [0, 0]}</pre> is the top left corner.
	<pre>{@code
	A ------ B
	| Object |
	D ------ C
	}</pre>
     */
	public native @ByRef SL_Vector2 bounding_box_2d(int i); public native SL_BodyData bounding_box_2d(int i, SL_Vector2 setter);
	@MemberGetter public native SL_Vector2 bounding_box_2d();
	/**
	\brief 3D centroid of the head of the body/person.
	\note It is defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
	 */
	public native @ByRef SL_Vector3 head_position(); public native SL_BodyData head_position(SL_Vector3 setter);

	/**
	\brief 3D body/person dimensions: width, height, length.
	\note It is defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
	 */
	public native @ByRef SL_Vector3 dimensions(); public native SL_BodyData dimensions(SL_Vector3 setter);
	/**
	\brief 3D bounding box of the body/person represented as eight 3D points.
	\note It is defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
    <pre>{@code
       1 ------ 2
      /        /|
     0 ------ 3 |
     | Object | 6
     |        |/
     4 ------ 7
    }</pre>
	 */
	public native @ByRef SL_Vector3 bounding_box(int i); public native SL_BodyData bounding_box(int i, SL_Vector3 setter);
	@MemberGetter public native SL_Vector3 bounding_box();
	/**
	\brief 3D bounding box of the head of the body/person represented as eight 3D points.
	\note It is defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
	 */
	public native @ByRef SL_Vector3 head_bounding_box(int i); public native SL_BodyData head_bounding_box(int i, SL_Vector3 setter);
	@MemberGetter public native SL_Vector3 head_bounding_box();
	/**
	\brief 2D bounding box of the head of the body/person represented as four 2D points starting at the top left corner and rotation clockwise.
	\note Expressed in pixels on the original image resolution, <pre>{@code [0, 0]}</pre> is the top left corner.
	 */
	public native @ByRef SL_Vector2 head_bounding_box_2d(int i); public native SL_BodyData head_bounding_box_2d(int i, SL_Vector2 setter);
	@MemberGetter public native SL_Vector2 head_bounding_box_2d();
	/**
	\brief Set of useful points representing the human body in 2D.
	\note Expressed in pixels on the original image resolution, <pre>{@code [0, 0]}</pre> is the top left corner.
	\warning In some cases, eg. body partially out of the image, some keypoints can not be detected. They will have negatives coordinates.
	 */
	public native @ByRef SL_Vector2 keypoint_2d(int i); public native SL_BodyData keypoint_2d(int i, SL_Vector2 setter);
	@MemberGetter public native SL_Vector2 keypoint_2d();
	/**
	\brief Set of useful points representing the human body in 3D.
	\note They are defined in SL_InitParameters.coordinate_unit and expressed in SL_RuntimeParameters.reference_frame.
	\warning In some cases, eg. body partially out of the image or missing depth data, some keypoints can not be detected. They will have non finite values.
	 */
	public native @ByRef SL_Vector3 keypoint(int i); public native SL_BodyData keypoint(int i, SL_Vector3 setter);
	@MemberGetter public native SL_Vector3 keypoint();

	/**
	\brief Array of detection confidences for each keypoint.
	\note They can not be lower than the SL_BodyTrackingRuntimeParameters.detection_confidence_threshold.
	\warning In some cases, eg. body partially out of the image or missing depth data, some keypoints can not be detected. They will have non finite values.
	 */
	public native float keypoint_confidence(int i); public native SL_BodyData keypoint_confidence(int i, float setter);
	@MemberGetter public native FloatPointer keypoint_confidence();
	/**
	\brief Array of detection covariance for each keypoint.
	\warning In some cases, eg. body partially out of the image or missing depth data, some keypoints can not be detected. Their covariances will be 0.
	 */
	public native float keypoint_covariances(int i, int j); public native SL_BodyData keypoint_covariances(int i, int j, float setter);
	@MemberGetter public native @Cast("float(* /*[38]*/ )[6]") FloatPointer keypoint_covariances();
	/**
	\brief Array of local position (position of the child keypoint with respect to its parent expressed in its parent coordinate frame) for each keypoint.
	\note They are expressed in \ref SL_REFERENCE_FRAME_CAMERA or \ref SL_REFERENCE_FRAME_WORLD.
	\warning Not available with \ref SL_BODY_FORMAT_BODY_18.
	*/
	public native @ByRef SL_Vector3 local_position_per_joint(int i); public native SL_BodyData local_position_per_joint(int i, SL_Vector3 setter);
	@MemberGetter public native SL_Vector3 local_position_per_joint();
	/**
	\brief Array of local orientation for each keypoint.
	\note The orientation is represented by a \ref SL_Quaternion (<pre>{@code SL_Quaternion q = SL_Quaternion(qx, qy, qz, qw);}</pre>)
	\warning Not available with \ref SL_BODY_FORMAT_BODY_18.
	*/
	public native @ByRef SL_Quaternion local_orientation_per_joint(int i); public native SL_BodyData local_orientation_per_joint(int i, SL_Quaternion setter);
	@MemberGetter public native SL_Quaternion local_orientation_per_joint();
	/**
	\brief Global root orientation of the skeleton.
	<p>
	The orientation is also represented by a quaternion with the same format as \ref local_orientation_per_joint.
	\note The global root position is already accessible in \ref keypoint attribute by using the root index of a given \ref SL_BODY_FORMAT.
	\warning Not available with \ref SL_BODY_FORMAT_BODY_18.
	*/
	public native @ByRef SL_Quaternion global_root_orientation(); public native SL_BodyData global_root_orientation(SL_Quaternion setter);
}

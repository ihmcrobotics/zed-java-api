// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package us.ihmc.zed.global;

import us.ihmc.zed.*;

import org.bytedeco.cuda.cudart.CUctx_st;
import org.bytedeco.cuda.cudart.CUstream_st;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class zed extends us.ihmc.zed.ZEDJavaAPIConfig {
    static { Loader.load(); }

// Parsed from types_c.h

// #ifndef __TYPES_C_H__
// #define __TYPES_C_H__

/**
 * \file
 * */

public static final int MAX_FUSED_CAMERAS = 20;
public static final int WITH_OBJECT_DETECTION = 1;
// #ifdef WITH_UNLIMITED_CAMERA
public static final int MAX_CAMERA_PLUGIN = 20;
// #else
// #endif

public static final int MAX_SUBMESH = 1000;

// #include <stdbool.h>

// #include "cuda.h"
// Targeting ../SL_Quaternion.java


// Targeting ../SL_Vector2.java


// Targeting ../SL_Vector3.java


// Targeting ../SL_Vector4.java


// Targeting ../SL_Uchar2.java


// Targeting ../SL_Uchar3.java


// Targeting ../SL_Uchar4.java


// Targeting ../SL_Matrix4f.java


// Targeting ../SL_Matrix3f.java


// Targeting ../SL_PoseData.java



/** enum UNITY_PLAN_TYPE */
public static final int
	UNITY_PLAN_TYPE_FLOOR = 0,
	UNITY_PLAN_TYPE_HIT_HORIZONTAL = 1,
	UNITY_PLAN_TYPE_HIT_VERTICAL = 2,
	UNITY_PLAN_TYPE_HIT_UNKNOWN = 3;
// Targeting ../SL_PlaneData.java


// Targeting ../SL_IMUData.java


// Targeting ../SL_BarometerData.java



/**
* \brief Lists the different states of the magnetic heading.
*/
/** enum SL_HEADING_STATE */
public static final int
	/** The heading is reliable and not affected by iron interferences. */
	SL_HEADING_STATE_GOOD = 0,
	/** The heading is reliable, but affected by slight iron interferences. */
	SL_HEADING_STATE_OK = 1,
	/** The heading is not reliable because affected by strong iron interferences. */
	SL_HEADING_STATE_NOT_GOOD = 2,
	/** The magnetometer has not been calibrated. */
	SL_HEADING_STATE_NOT_CALIBRATED = 3,
	/** The magnetometer sensor is not available. */
	SL_HEADING_STATE_MAG_NOT_AVAILABLE = 4,
	SL_HEADING_STATE_LAST = 5;
// Targeting ../SL_MagnetometerData.java


// Targeting ../SL_TemperatureData.java


// Targeting ../SL_SensorsData.java



/** enum USB_DEVICE */
public static final int
	USB_DEVICE_OCULUS = 0,
	USB_DEVICE_HTC = 1,
	USB_DEVICE_STEREOLABS = 2;
// Targeting ../USB_product.java



/**
\brief Lists error codes in the ZED SDK.
 */
/** enum SL_ERROR_CODE */
public static final int
	/** The image could be corrupted, Enabled with the parameter InitParameters::enable_image_validity_check.*/
	SL_ERROR_CODE_CORRUPTED_FRAME = -2,
	/** The camera is currently rebooting.*/
	SL_ERROR_CODE_CAMERA_REBOOTING = -1,
	/** Standard code for successful behavior.*/
	SL_ERROR_CODE_SUCCESS = 0,
	/** Standard code for unsuccessful behavior.*/
	SL_ERROR_CODE_FAILURE = 1,
	/** No GPU found or CUDA capability of the device is not supported.*/
	SL_ERROR_CODE_NO_GPU_COMPATIBLE = 2,
	/** Not enough GPU memory for this depth mode. Try a different mode (such as \ref SL_DEPTH_MODE_PERFORMANCE), or increase the minimum depth value (see SL_InitParameters.depth_minimum_distance).*/
	SL_ERROR_CODE_NOT_ENOUGH_GPU_MEMORY = 3,
	/** No camera was detected.*/
	SL_ERROR_CODE_CAMERA_NOT_DETECTED = 4,
	/** The MCU that controls the sensors module has an invalid serial number. You can try to recover it by launching the <b>ZED Diagnostic</b> tool from the command line with the option <code>-r</code>.*/
	SL_ERROR_CODE_SENSORS_NOT_INITIALIZED = 5,
	/** A camera with sensor is detected but the sensors (IMU, barometer, ...) cannot be opened. Only the \ref SL_MODEL_ZED does not has sensors. Unplug/replug is required.*/
	SL_ERROR_CODE_SENSORS_NOT_AVAILABLE = 6,
	/** In case of invalid resolution parameter, such as an upsize beyond the original image size in \ref sl_retrieve_image. */
	SL_ERROR_CODE_INVALID_RESOLUTION = 7,
	/** Insufficient bandwidth for the correct use of the camera. This issue can occur when you use multiple cameras or a USB 2.0 port.*/
	SL_ERROR_CODE_LOW_USB_BANDWIDTH = 8,
	/** The calibration file of the camera is not found on the host machine. Use <b>ZED Explorer</b> or <b>ZED Calibration</b> to download the factory calibration file.*/
	SL_ERROR_CODE_CALIBRATION_FILE_NOT_AVAILABLE = 9,
	/** The calibration file is not valid. Try to download the factory calibration file or recalibrate your camera using <b>ZED Calibration</b>.*/
	SL_ERROR_CODE_INVALID_CALIBRATION_FILE = 10,
	/** The provided SVO file is not valid.*/
	SL_ERROR_CODE_INVALID_SVO_FILE = 11,
	/** An error occurred while trying to record an SVO (not enough free storage, invalid file, ...).*/
	SL_ERROR_CODE_SVO_RECORDING_ERROR = 12,
	/** An SVO related error, occurs when NVIDIA based compression cannot be loaded.*/
	SL_ERROR_CODE_SVO_UNSUPPORTED_COMPRESSION = 13,
	/** SVO end of file has been reached.\n No frame will be available until the SVO position is reset.*/
	SL_ERROR_CODE_END_OF_SVOFILE_REACHED = 14,
	/** The requested coordinate system is not available.*/
	SL_ERROR_CODE_INVALID_COORDINATE_SYSTEM = 15,
	/** The firmware of the camera is out of date. Update to the latest version.*/
	SL_ERROR_CODE_INVALID_FIRMWARE = 16,
	/** Invalid parameters have been given for the function. */
	SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS = 17,
	/** A CUDA error has been detected in the process, in \ref sl_grab() or sl_retrieve_xxx() only. Activate verbose in \ref sl_open_camera() for more info.*/
	SL_ERROR_CODE_CUDA_ERROR = 18,
	/** The ZED SDK is not initialized. Probably a missing call to \ref sl_open_camera().*/
	SL_ERROR_CODE_CAMERA_NOT_INITIALIZED = 19,
	/** Your NVIDIA driver is too old and not compatible with your current CUDA version. */
	SL_ERROR_CODE_NVIDIA_DRIVER_OUT_OF_DATE = 20,
	/** The call of the function is not valid in the current context. Could be a missing call of \ref sl_open_camera(). */
	SL_ERROR_CODE_INVALID_FUNCTION_CALL = 21,
	/** The ZED SDK was not able to load its dependencies or some assets are missing. Reinstall the ZED SDK or check for missing dependencies (cuDNN, TensorRT). */
	SL_ERROR_CODE_CORRUPTED_SDK_INSTALLATION = 22,
	/** The installed ZED SDK is incompatible with the one used to compile the program. */
	SL_ERROR_CODE_INCOMPATIBLE_SDK_VERSION = 23,
	/** The given area file does not exist. Check the path. */
	SL_ERROR_CODE_INVALID_AREA_FILE = 24,
	/** The area file does not contain enough data to be used or the \ref SL_DEPTH_MODE used during the creation of the area file is different from the one currently set. */
	SL_ERROR_CODE_INCOMPATIBLE_AREA_FILE = 25,
	/** Failed to open the camera at the proper resolution. Try another resolution or make sure that the UVC driver is properly installed.*/
	SL_ERROR_CODE_CAMERA_FAILED_TO_SETUP = 26,
	/** Your camera can not be opened. Try replugging it to another port or flipping the USB-C connector (if there is one).*/
	SL_ERROR_CODE_CAMERA_DETECTION_ISSUE = 27,
	/** Cannot start the camera stream. Make sure your camera is not already used by another process or blocked by firewall or antivirus.*/
	SL_ERROR_CODE_CANNOT_START_CAMERA_STREAM = 28,
	/**  No GPU found. CUDA is unable to list it. Can be a driver/reboot issue.*/
	SL_ERROR_CODE_NO_GPU_DETECTED = 29,
	/** Plane not found. Either no plane is detected in the scene, at the location or corresponding to the floor, or the floor plane doesn't match the prior given.*/
	SL_ERROR_CODE_PLANE_NOT_FOUND = 30,
	/** The module you try to use is not compatible with your camera \ref SL_MODEL. \note \ref SL_MODEL_ZED does not has an IMU and does not support the AI modules.*/
	SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CAMERA = 31,
	/** The module needs the sensors to be enabled (see SL_InitParameters.sensors_required). */
	SL_ERROR_CODE_MOTION_SENSORS_REQUIRED = 32,
	/** The module needs a newer version of CUDA. */
	SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CUDA_VERSION = 33,
	/** The input data does not contains the high frequency sensors data, this is usually because it requires newer SVO/Streaming. In order to work this modules needs inertial data present in it input.*/
	SL_ERROR_CODE_SENSORS_DATA_REQUIRED = 34;

/**
\brief Lists available resolutions.
\note The VGA resolution does not respect the 640*480 standard to better fit the camera sensor (672*376 is used).
\warning All resolutions are not available for every camera.
\warning You can find the available resolutions for each camera in <a href="https://www.stereolabs.com/docs/video/camera-controls#selecting-a-resolution">our documentation</a>.
 */
/** enum SL_RESOLUTION */
public static final int
	/** 3856x2180 for imx678 mono*/
	SL_RESOLUTION_HD4K = 0,
	/** 2208*1242 (x2) \n Available FPS: 15*/
	SL_RESOLUTION_HD2K = 1,
	/** 1920*1080 (x2) \n Available FPS: 15, 30*/
	SL_RESOLUTION_HD1080 = 2,
	/** 1920*1200 (x2) \n Available FPS: 15, 30, 60*/
	SL_RESOLUTION_HD1200 = 3,
	/** 1280*720 (x2) \n Available FPS: 15, 30, 60*/
	SL_RESOLUTION_HD720 = 4,
	/** 960*600 (x2) \n Available FPS: 15, 30, 60, 120*/
	SL_RESOLUTION_SVGA = 5,
	/** 672*376 (x2) \n Available FPS: 15, 30, 60, 100*/
	SL_RESOLUTION_VGA = 6,
	/** Select the resolution compatible with the camera: <ul><li>ZED X/X Mini: \ref SL_RESOLUTION_HD1200</li><li>other cameras: \ref SL_RESOLUTION_HD720</li></ul>*/
	SL_RESOLUTION_AUTO = 7;

/**
\brief Lists available units for measures.
 */
/** enum SL_UNIT */
public static final int
	/** International System (1/1000 meters) */
	SL_UNIT_MILLIMETER = 0,
	/** International System (1/100 meters) */
	SL_UNIT_CENTIMETER = 1,
	/** International System (1 meter) */
	SL_UNIT_METER = 2,
	/** Imperial Unit (1/12 feet) */
	SL_UNIT_INCH = 3,
	/** Imperial Unit (1 foot) */
	SL_UNIT_FOOT = 4;

/**
\brief Lists available coordinates systems for positional tracking and 3D measures.
<p>
\image html CoordinateSystem.webp
 */
/** enum SL_COORDINATE_SYSTEM */
public static final int
	/** Standard coordinates system in computer vision.\n Used in OpenCV: see <a href="http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html">here</a>. */
	SL_COORDINATE_SYSTEM_IMAGE = 0,
	/** Left-handed with Y up and Z forward.\n Used in Unity with DirectX. */
	SL_COORDINATE_SYSTEM_LEFT_HANDED_Y_UP = 1,
	/** Right-handed with Y pointing up and Z backward.\n Used in OpenGL. */
	SL_COORDINATE_SYSTEM_RIGHT_HANDED_Y_UP = 2,
	/** Right-handed with Z pointing up and Y forward.\n Used in 3DSMax. */
	SL_COORDINATE_SYSTEM_RIGHT_HANDED_Z_UP = 3,
	/** Left-handed with Z axis pointing up and X forward.\n Used in Unreal Engine. */
	SL_COORDINATE_SYSTEM_LEFT_HANDED_Z_UP = 4,
	/** Right-handed with Z pointing up and X forward.\n Used in ROS (REP 103). */
	SL_COORDINATE_SYSTEM_RIGHT_HANDED_Z_UP_X_FWD = 5;

/**
\brief Lists possible camera states.
 */
/** enum SL_CAMERA_STATE */
public static final int
	/** The camera can be opened by the ZED SDK. */
	SL_CAMERA_STATE_AVAILABLE = 0,
	/** The camera is already opened and unavailable. */
	SL_CAMERA_STATE_NOT_AVAILABLE = 1;

/**
\brief Lists ZED camera model.
 */
/** enum SL_MODEL */
public static final int
	/** ZED camera model */
	SL_MODEL_ZED = 0,
	/** ZED Mini (ZED M) camera model */
	SL_MODEL_ZED_M = 1,
	/** ZED 2 camera model */
	SL_MODEL_ZED2 = 2,
	/** ZED 2i camera model */
	SL_MODEL_ZED2i = 3,
	/** ZED X camera model */
	SL_MODEL_ZED_X = 4,
	/** ZED X Mini (ZED XM) camera model */
	SL_MODEL_ZED_XM = 5,
	/** Virtual ZED-X generated from 2 ZED-XOne */
	SL_MODEL_VIRTUAL_ZED_X = 10,
	/** ZED XOne with global shutter AR0234 sensor */
	SL_MODEL_ZED_XONE_GS = 30,
	/** ZED XOne with 4K rolling shutter IMX678 sensor */
	SL_MODEL_ZED_XONE_UHD = 31;

/**
\brief Lists available memory type.
 */
/** enum SL_MEM */
public static final int
	/** Data will be stored on the CPU (processor side).*/
	SL_MEM_CPU = 0,
	/** Data will be stored on the GPU (graphic card side).*/
	SL_MEM_GPU = 1;

/**
\brief Lists available sensor types.
\note Sensors are not available on \ref SL_MODEL_ZED.
 */
/** enum SL_SENSOR_TYPE */
public static final int
	/** Three-axis accelerometer sensor to measure the inertial accelerations. */
	SL_SENSOR_TYPE_ACCELEROMETER = 0,
	/** Three-axis gyroscope sensor to measure the angular velocities. */
	SL_SENSOR_TYPE_GYROSCOPE = 1,
	/** Three-axis magnetometer sensor to measure the orientation of the device with respect to the Earth's magnetic field. */
	SL_SENSOR_TYPE_MAGNETOMETER = 2,
	/** Barometer sensor to measure the atmospheric pressure. */
	SL_SENSOR_TYPE_BAROMETER = 3;

/**
\brief Lists available measurement units of onboard sensors.
\note Sensors are not available on \ref SL_MODEL_ZED.
 */
/** enum SL_SENSORS_UNIT */
public static final int
	/** m/s² (acceleration) */
	SL_SENSORS_UNIT_M_SEC_2 = 0,
	/** deg/s (angular velocity) */
	SL_SENSORS_UNIT_DEG_SEC = 1,
	/** μT (magnetic field) */
	SL_SENSORS_UNIT_U_T = 2,
	/** hPa (atmospheric pressure) */
	SL_SENSORS_UNIT_HPA = 3,
	/** °C (temperature) */
	SL_SENSORS_UNIT_CELSIUS = 4,
	/** Hz (frequency) */
	SL_SENSORS_UNIT_HERTZ = 5;

/**
\brief Lists possible sides on which to get data from.
*/
/** enum SL_SIDE */
public static final int
	/** Left side only.*/
	SL_SIDE_LEFT = 0,
	/** Right side only.*/
	SL_SIDE_RIGHT = 1,
	/** Left and right side.*/
	SL_SIDE_BOTH = 2;

/**
\brief Lists available input types in the ZED SDK.
 */
/** enum SL_INPUT_TYPE */
public static final int
	/** USB input mode */
	SL_INPUT_TYPE_USB = 0,
	/**  SVO file input mode */
	SL_INPUT_TYPE_SVO = 1,
	/** STREAM input mode (requires to use sl_enable_streaming() / sl_disable_streaming() on the "sender" side) */
	SL_INPUT_TYPE_STREAM = 2,
	/** GMSL input mode (only on NVIDIA Jetson) */
	SL_INPUT_TYPE_GMSL = 3;

/**
\brief Lists possible types of position matrix used to store camera path and pose.
 */
/** enum SL_REFERENCE_FRAME */
public static final int
	/** SL_PoseData will contain the motion with reference to the world frame (previously called SL_PATH).*/
	SL_REFERENCE_FRAME_WORLD = 0,
	/** SL_PoseData will contain the motion with reference to the previous camera frame (previously called SL_POSE)*/
	SL_REFERENCE_FRAME_CAMERA = 1;

/**
\brief Lists possible time references for timestamps or data.
 */
/** enum SL_TIME_REFERENCE */
public static final int
	/** The requested timestamp or data will be at the time of the frame extraction. */
	SL_TIME_REFERENCE_IMAGE = 0,
	/** The requested timestamp or data will be at the time of the function call. */
	SL_TIME_REFERENCE_CURRENT = 1;

/**
\brief Lists the different encoding types for image streaming.
 */
/** enum SL_STREAMING_CODEC */
public static final int
	/** AVCHD/H264 encoding*/
	SL_STREAMING_CODEC_H264 = 0,
	/** HEVC/H265 encoding*/
	SL_STREAMING_CODEC_H265 = 1;

/**
\brief Lists available camera settings for the camera (contrast, hue, saturation, gain, ...).
\warning \ref SL_VIDEO_SETTINGS_GAIN and \ref SL_VIDEO_SETTINGS_EXPOSURE are linked in auto/default mode (see sl_set_camera_settings()).
 */
/** enum SL_VIDEO_SETTINGS */
public static final int
	/** Brightness control \n Affected value should be between 0 and 8. \note Not available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_BRIGHTNESS = 0,
	/** Contrast control \n Affected value should be between 0 and 8. \note Not available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_CONTRAST = 1,
	/** Hue control \n Affected value should be between 0 and 11. \note Not available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_HUE = 2,
	/** Saturation control \n Affected value should be between 0 and 8.*/
	SL_VIDEO_SETTINGS_SATURATION = 3,
	/** Digital sharpening control \n Affected value should be between 0 and 8.*/
	SL_VIDEO_SETTINGS_SHARPNESS = 4,
	/** ISP gamma control \n Affected value should be between 1 and 9.*/
	SL_VIDEO_SETTINGS_GAMMA = 5,
	/** Gain control \n Affected value should be between 0 and 100 for manual control. \note If \ref SL_VIDEO_SETTINGS_EXPOSURE is set to -1 (automatic mode), then \ref SL_VIDEO_SETTINGS_GAIN will be automatic as well.*/
	SL_VIDEO_SETTINGS_GAIN = 6,
	/** Exposure control \n Affected value should be between 0 and 100 for manual control.\n The exposition is mapped linearly in a percentage of the following max values.\n Special case for <code>\ref SL_VIDEO_SETTINGS_EXPOSURE = 0</code> that corresponds to 0.17072ms.\n The conversion to milliseconds depends on the framerate: <ul><li>15fps & <code>\ref SL_VIDEO_SETTINGS_EXPOSURE = 100</code> -> 19.97ms</li><li>30fps & <code>\ref SL_VIDEO_SETTINGS_EXPOSURE = 100</code> -> 19.97ms</li><li>60fps & <code>\ref SL_VIDEO_SETTINGS_EXPOSURE = 100</code> -> 10.84072ms</li><li>100fps & <code>\ref SL_VIDEO_SETTINGS_EXPOSURE = 100</code> -> 10.106624ms</li></ul>*/
	SL_VIDEO_SETTINGS_EXPOSURE = 7,
	/** Defines if the \ref SL_VIDEO_SETTINGS_GAIN and \ref SL_VIDEO_SETTINGS_EXPOSURE are in automatic mode or not.\n Setting \ref SL_VIDEO_SETTINGS_GAIN or \ref SL_VIDEO_SETTINGS_EXPOSURE values will automatically set this value to 0.*/
	SL_VIDEO_SETTINGS_AEC_AGC = 8,
	/** Defines the region of interest for automatic exposure/gain computation.\n To be used with dedicated sl_set_roi_for_aec_agc() / sl_get_roi_for_aec_agc() functions.*/
	SL_VIDEO_SETTINGS_AEC_AGC_ROI = 9,
	/** Color temperature control \n Affected value should be between 2800 and 6500 with a step of 100. \note Setting a value will automatically set \ref SL_VIDEO_SETTINGS_WHITEBALANCE_AUTO to 0.*/
	SL_VIDEO_SETTINGS_WHITEBALANCE_TEMPERATURE = 10,
	/** Defines if the white balance is in automatic mode or not.*/
	SL_VIDEO_SETTINGS_WHITEBALANCE_AUTO = 11,
	/** Status of the front LED of the camera.\n Set to 0 to disable the light, 1 to enable the light.\n Default value is on. \note Requires camera firmware 1523 at least.*/
	SL_VIDEO_SETTINGS_LED_STATUS = 12,
	/** Real exposure time control in microseconds. \note Only available for ZED X/X Mini cameras.\note Replace \ref SL_VIDEO_SETTINGS_EXPOSURE setting.*/
	SL_VIDEO_SETTINGS_EXPOSURE_TIME = 13,
	/** Real analog gain (sensor) control in mDB.\n The range is defined by Jetson DTS and by default [1000-16000]. \note Only available for ZED X/X Mini cameras.\note Replace \ref SL_VIDEO_SETTINGS_GAIN settings.*/
	SL_VIDEO_SETTINGS_ANALOG_GAIN = 14,
	/** Real digital gain (ISP) as a factor. \n The range is defined by Jetson DTS and by default [1-256]. \note Only available for ZED X/X Mini cameras.\note Replace \ref SL_VIDEO_SETTINGS_GAIN settings.*/
	SL_VIDEO_SETTINGS_DIGITAL_GAIN = 15,
	/** Range of exposure auto control in microseconds.\n Used with sl_get_camera_settings_min_max().\n Min/max range between max range defined in DTS.\n By default: [28000 - <fps_time> or 19000] us.\note Only available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_AUTO_EXPOSURE_TIME_RANGE = 16,
	/** Range of sensor gain in automatic control.\n Used with sl_get_camera_settings_min_max().\n Min/max range between max range defined in DTS.\n By default: [1000 - 16000] mdB. \note Only available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_AUTO_ANALOG_GAIN_RANGE = 17,
	/** Range of digital ISP gain in automatic control.\n Used with sl_get_camera_settings_min_max().\n Min/max range between max range defined in DTS.\n By default: [1 - 256]. \note Only available for ZED X/X Mini cameras. */
	SL_VIDEO_SETTINGS_AUTO_DIGITAL_GAIN_RANGE = 18,
	/** Exposure-target compensation made after auto exposure.\n Reduces the overall illumination target by factor of F-stops.\n Affected value should be between 0 and 100 (mapped between [-2.0,2.0]).\n Default value is 50, i.e. no compensation applied. \note Only available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_EXPOSURE_COMPENSATION = 19,
	/** Level of denoising applied on both left and right images.\n Affected value should be between 0 and 100.\n Default value is 50. \note Only available for ZED X/X Mini cameras.*/
	SL_VIDEO_SETTINGS_DENOISING = 20,
	SL_VIDEO_SETTINGS_LAST = 21;

@MemberGetter public static native int SL_VIDEO_SETTINGS_VALUE_AUTO();

/**
\brief Lists retrievable measures.
*/
/** enum SL_MEASURE */
public static final int
	/** Disparity map. Each pixel contains 1 float.\n Type: \ref SL_MAT_TYPE_F32_C1*/
	SL_MEASURE_DISPARITY = 0,
	/** Depth map in sl::UNIT defined in SL_InitParameters::coordinate_unit. Each pixel contains 1 float.\n Type: \ref SL_MAT_TYPE_F32_C1*/
	SL_MEASURE_DEPTH = 1,
	/** Certainty/confidence of the depth map. Each pixel contains 1 float.\n Type: \ref SL_MAT_TYPE_F32_C1*/
	SL_MEASURE_CONFIDENCE = 2,
	/** Point cloud. Each pixel contains 4 float (X, Y, Z, not used).\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZ = 3,
	/** Colored point cloud. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the RGBA color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZRGBA = 4,
	/** Colored point cloud. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the BGRA color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZBGRA = 5,
	/** Colored point cloud. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the ARGB color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZARGB = 6,
	/** Colored point cloud. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the ABGR color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZABGR = 7,
	/** Normal vectors map. Each pixel contains 4 float (X, Y, Z, 0).\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_NORMALS = 8,
	/** Disparity map for right sensor. Each pixel contains 1 float.\n Type: \ref SL_MAT_TYPE_F32_C1*/
	SL_MEASURE_DISPARITY_RIGHT = 9,
	/** Depth map for right sensor. Each pixel contains 1 float.\n Type: \ref SL_MAT_TYPE_F32_C1*/
	SL_MEASURE_DEPTH_RIGHT = 10,
	/** Point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, not used).\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZ_RIGHT = 11,
	/** Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the RGBA color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZRGBA_RIGHT = 12,
	/** Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the BGRA color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZBGRA_RIGHT = 13,
	/** Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the ARGB color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZARGB_RIGHT = 14,
	/** Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color).\n The color should to be read as an unsigned char[4] representing the ABGR color.\n Type: \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_XYZABGR_RIGHT = 15,
	/** Normal vectors map for right view. Each pixel contains 4 float (X, Y, Z, 0).\n Type:  \ref SL_MAT_TYPE_F32_C4*/
	SL_MEASURE_NORMALS_RIGHT = 16,
	/** Depth map in millimeter whatever the sl::UNIT defined in SL_InitParameters::coordinate_unit.\n Invalid values are set to 0 and depth values are clamped at 65000.\n Each pixel contains 1 unsigned short.\n Type: \ref SL_MAT_TYPE_U16_C1.*/
	SL_MEASURE_DEPTH_U16_MM = 17,
	/** Depth map in millimeter for right sensor. Each pixel contains 1 unsigned short.\n Type: \ref SL_MAT_TYPE_U16_C1.*/
	SL_MEASURE_DEPTH_U16_MM_RIGHT = 18;

/**
\brief Lists available views.
 */
/** enum SL_VIEW */
public static final int
	/** Left BGRA image. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 */
	SL_VIEW_LEFT = 0,
	/**  Right BGRA image. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 */
	SL_VIEW_RIGHT = 1,
	/** Left gray image. Each pixel contains 1 unsigned char.\n Type: \ref SL_MAT_TYPE_U8_C1 */
	SL_VIEW_LEFT_GRAY = 2,
	/** Right gray image. Each pixel contains 1 unsigned char.\n Type: \ref SL_MAT_TYPE_U8_C1 */
	SL_VIEW_RIGHT_GRAY = 3,
	/** Left BGRA unrectified image. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 */
	SL_VIEW_LEFT_UNRECTIFIED = 4,
	/** Right BGRA unrectified image. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 */
	SL_VIEW_RIGHT_UNRECTIFIED = 5,
	/** Left gray unrectified image. Each pixel contains 1 unsigned char.\n Type: \ref SL_MAT_TYPE_U8_C1 */
	SL_VIEW_LEFT_UNRECTIFIED_GRAY = 6,
	/** Right gray unrectified image. Each pixel contains 1 unsigned char.\n Type: \ref SL_MAT_TYPE_U8_C1 */
	SL_VIEW_RIGHT_UNRECTIFIED_GRAY = 7,
	/** Left and right image (the image width is therefore doubled). Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 */
	SL_VIEW_SIDE_BY_SIDE = 8,
	/** Color rendering of the depth. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 \note Use \ref SL_MEASURE_DEPTH with \ref sl_retrieve_measure() to get depth values.*/
	SL_VIEW_DEPTH = 9,
	/** Color rendering of the depth confidence. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 \note Use \ref SL_MEASURE_CONFIDENCE with \ref sl_retrieve_measure() to get confidence values.*/
	SL_VIEW_CONFIDENCE = 10,
	/** Color rendering of the normals. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 \note Use \ref SL_MEASURE_NORMALS with \ref sl_retrieve_measure() to get normal values.*/
	SL_VIEW_NORMALS = 11,
	/** Color rendering of the right depth mapped on right sensor. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 \note Use \ref SL_MEASURE_DEPTH_RIGHT with \ref sl_retrieve_measure() to get depth right values.*/
	SL_VIEW_DEPTH_RIGHT = 12,
	/** Color rendering of the normals mapped on right sensor. Each pixel contains 4 unsigned char (B, G, R, A).\n Type: \ref SL_MAT_TYPE_U8_C4 \note Use \ref SL_MEASURE_NORMALS_RIGHT with \ref sl_retrieve_measure() to get normal right values.*/
	SL_VIEW_NORMALS_RIGHT = 13;

/**
\brief Lists the different states of object tracking.
 */
/** enum SL_OBJECT_TRACKING_STATE */
public static final int
	/** The tracking is not yet initialized.\n The object id is not usable. */
	SL_OBJECT_TRACKING_STATE_OFF = 0,
	/** The object is tracked. */
	SL_OBJECT_TRACKING_STATE_OK = 1,
	/** The object could not be detected in the image and is potentially occluded.\n The trajectory is estimated.*/
	SL_OBJECT_TRACKING_STATE_SEARCHING = 2,
	/** This is the last searching state of the track.\n The track will be deleted in the next sl_retrieve_objects(). */
	SL_OBJECT_TRACKING_STATE_TERMINATE = 3;

/**
\brief Lists the different states of positional tracking.
 */
/** enum SL_POSITIONAL_TRACKING_STATE */
public static final int
	/** \warn DEPRECATED: This state is no longer in use.*/
	SL_POSITIONAL_TRACKING_STATE_SEARCHING = 0,
	/** The positional tracking is working normally.*/
	SL_POSITIONAL_TRACKING_STATE_OK = 1,
	/** The positional tracking is not enabled.*/
	SL_POSITIONAL_TRACKING_STATE_OFF = 2,
	/** The effective FPS is too low to give proper results for motion tracking.\n Consider using performance parameters (\ref SL_DEPTH_MODE_PERFORMANCE, low camera resolution (\ref SL_RESOLUTION_VGA / \ref SL_RESOLUTION_SVGA or \ref SL_RESOLUTION_HD720).*/
	SL_POSITIONAL_TRACKING_STATE_FPS_TOO_LOW = 3,
	/** The camera is searching for the floor plane to locate itself with respect to it.\n The \ref SL_REFERENCE_FRAME_WORLD will be set afterward.*/
	SL_POSITIONAL_TRACKING_STATE_SEARCHING_FLOOR_PLANE = 4,
	/** The tracking module was unable to perform tracking from the previous frame to the current frame. */
	SL_POSITIONAL_TRACKING_STATE_UNAVAILABLE = 5;

/**
\brief Report the status of current odom tracking.
 */
/** enum SL_ODOMETRY_STATUS */
public static final int
	/** The positional tracking module successfully tracked from the previous frame to the current frame. */
	SL_ODOMETRY_STATUS_OK = 0,
	/** The positional tracking module failed to track from the previous frame to the current frame. */
	SL_ODOMETRY_STATUS_UNAVAILABLE = 1;

/**
\brief Report the status of current map tracking.
 */
/** enum SL_SPATIAL_MEMORY_STATUS */
public static final int
	/** The positional tracking module is operating normally. */
	SL_MAP_TRACKING_STATUS_OK = 0,
	/** The positional tracking module detected a loop and corrected its position. */
	SL_MAP_TRACKING_STATUS_LOOP_CLOSED = 1,
	/** The positional tracking module is searching for recognizable areas in the global map to relocate. */
	SL_MAP_TRACKING_STATUS_SEARCHING = 2,
	/** Spatial memory is disabled */
	SL_MAP_TRACKING_STATUS_OFF = 3;

/**
\brief Lists the mode of positional tracking that can be used.
*/
/** enum SL_POSITIONAL_TRACKING_MODE */
public static final int
	/** Default mode. Best compromise in performance and accuracy. */
	SL_POSITIONAL_TRACKING_MODE_GEN_1 = 0,
	/** Next generation of positional tracking, allow better accuracy. */
	SL_POSITIONAL_TRACKING_MODE_GEN_2 = 1;

/**
\brief Report the status of the positional tracking fusion.
 */
/** enum SL_POSITIONAL_TRACKING_FUSION_STATUS */
public static final int
	SL_POSITIONAL_TRACKING_FUSION_STATUS_VISUAL_INERTIAL = 0,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_VISUAL = 1,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_INERTIAL = 2,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_GNSS = 3,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_VISUAL_INERTIAL_GNSS = 4,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_VISUAL_GNSS = 5,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_INERTIAL_GNSS = 6,
	SL_POSITIONAL_TRACKING_FUSION_STATUS_UNAVAILABLE = 7;
// Targeting ../SL_PositionalTrackingStatus.java



/**
\enum SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE
\brief Lists the different states of region of interest auto detection.
 */
/** enum SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE */
public static final int
	/** The region of interest auto detection is initializing.*/
	SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE_RUNNING = 0,
	/** The region of interest mask is ready, if auto_apply was enabled, the region of interest mask is being used*/
	SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE_READY = 1,
	/** The region of interest auto detection is not enabled*/
	SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE_NOT_ENABLED = 2;


/**
\brief Lists the different states of spatial memory area export.
 */
/** enum SL_AREA_EXPORTING_STATE */
public static final int
	/** The spatial memory file has been successfully created.*/
	SL_AREA_EXPORTING_STATE_SUCCESS = 0,
	/** The spatial memory is currently being written.*/
	SL_AREA_EXPORTING_STATE_RUNNING = 1,
	/** The spatial memory file exportation has not been called.*/
	SL_AREA_EXPORTING_STATE_NOT_STARTED = 2,
	/** The spatial memory contains no data, the file is empty.*/
	SL_AREA_EXPORTING_STATE_FILE_EMPTY = 3,
	/** The spatial memory file has not been written because of a wrong file name.*/
	SL_AREA_EXPORTING_STATE_FILE_ERROR = 4,
	/** The spatial memory learning is disabled. No file can be created.*/
	SL_AREA_EXPORTING_STATE_SPATIAL_MEMORY_DISABLED = 5;

/**
\brief Lists the different states of spatial mapping.
 */
/** enum SL_SPATIAL_MAPPING_STATE */
public static final int
	/** The spatial mapping is initializing.*/
	SL_SPATIAL_MAPPING_STATE_INITIALIZING = 0,
	/** The depth and tracking data were correctly integrated in the mapping algorithm.*/
	SL_SPATIAL_MAPPING_STATE_OK = 1,
	/** The maximum memory dedicated to the scanning has been reached.\n The mesh will no longer be updated.*/
	SL_SPATIAL_MAPPING_STATE_NOT_ENOUGH_MEMORY = 2,
	/** sl_enable_spatial_mapping() wasn't called or the scanning was stopped and not relaunched.*/
	SL_SPATIAL_MAPPING_STATE_NOT_ENABLED = 3,
	/** The effective FPS is too low to give proper results for spatial mapping.\n Consider using performance parameters (\ref SL_DEPTH_MODE_PERFORMANCE, low camera resolution (\ref SL_RESOLUTION_VGA / \ref SL_RESOLUTION_SVGA or \ref SL_RESOLUTION_HD720).*/
	SL_SPATIAL_MAPPING_STATE_FPS_TOO_LOW = 4;

/**
\brief Lists the types of spatial maps that can be created.
 */
/** enum SL_SPATIAL_MAP_TYPE */
public static final int
	/** The geometry is represented by a set of vertices connected by edges and forming faces.\n No color information is available.*/
	SL_SPATIAL_MAP_TYPE_MESH = 0,
	/** The geometry is represented by a set of 3D colored points.*/
	SL_SPATIAL_MAP_TYPE_FUSED_POINT_CLOUD = 1;

/**
\brief Lists available mesh filtering intensities.
 */
/** enum SL_MESH_FILTER */
public static final int
	/** Clean the mesh by closing small holes and removing isolated faces.*/
	SL_MESH_FILTER_LOW = 0,
	/** Soft faces decimation and smoothing.*/
	SL_MESH_FILTER_MEDIUM = 1,
	/** Drastically reduce the number of faces and apply a soft smooth.*/
	SL_MESH_FILTER_HIGH = 2;

/**
\brief Lists available mesh file formats.
 */
/** enum SL_MESH_FILE_FORMAT */
public static final int
	/** Contains only vertices and faces.*/
	SL_MESH_FILE_FORMAT_PLY = 0,
	/** Contains only vertices and faces encoded in binary.*/
	SL_MESH_FILE_FORMAT_PLY_BIN = 1,
	/** Contains vertices, normals, faces, and texture information (if possible).*/
	SL_MESH_FILE_FORMAT_OBJ = 2;

/**
\brief Lists available depth computation modes.
 */
/** enum SL_DEPTH_MODE */
public static final int
	SL_DEPTH_MODE_NONE = 0, /** No depth map computation.\n Only rectified stereo images will be available.*/
	SL_DEPTH_MODE_PERFORMANCE = 1, /** Computation mode optimized for speed.*/
	/** Computation mode designed for challenging areas with untextured surfaces.*/
	SL_DEPTH_MODE_QUALITY = 2,
	/** Computation mode that favors edges and sharpness.\n Requires more GPU memory and computation power.*/
	SL_DEPTH_MODE_ULTRA = 3,
	/** End to End Neural disparity estimation.\n Requires AI module. */
	SL_DEPTH_MODE_NEURAL = 4,
	/** More accurate Neural disparity estimation.\n Requires AI module. */
	SL_DEPTH_MODE_NEURAL_PLUS = 5;

/**
\brief Lists possible flip modes of the camera.
 */
/** enum SL_FLIP_MODE */
public static final int
	/** No flip applied. Default behavior.*/
	SL_FLIP_MODE_OFF = 0,
	/** Images and camera sensors' data are flipped useful when your camera is mounted upside down.*/
	SL_FLIP_MODE_ON = 1,
	/** In LIVE mode, use the camera orientation (if an IMU is available) to set the flip mode.\n In SVO mode, read the state of this enum when recorded.*/
	SL_FLIP_MODE_AUTO = 2;

/**
\brief Lists available copy operation on matrix.
 */
/** enum SL_COPY_TYPE */
public static final int
	/** Copy data from CPU to CPU.*/
	SL_COPY_TYPE_CPU_CPU = 0,
	/** Copy data from CPU to GPU.*/
	SL_COPY_TYPE_CPU_GPU = 1,
	/** copy data from GPU to GPU.*/
	SL_COPY_TYPE_GPU_GPU = 2,
	/** Copy data from GPU to CPU.*/
	SL_COPY_TYPE_GPU_CPU = 3;

/**
\brief Lists available compression modes for SVO recording.
\note \ref SL_SVO_COMPRESSION_MODE_LOSSLESS is an improvement of previous lossless compression (used in ZED Explorer), even if size may be bigger, compression time is much faster.
 */
/** enum SL_SVO_COMPRESSION_MODE */
public static final int
	/** PNG/ZSTD (lossless) CPU based compression.\n Average size: 42% of RAW*/
	SL_SVO_COMPRESSION_MODE_LOSSLESS = 0,
	/** H264 (AVCHD) GPU based compression.\n Average size: 1% of RAW \note Requires a NVIDIA GPU.*/
	SL_SVO_COMPRESSION_MODE_H264 = 1,
	/**  H265 (HEVC) GPU based compression.\n Average size: 1% of RAW \note Requires a NVIDIA GPU.*/
	SL_SVO_COMPRESSION_MODE_H265 = 2,
	/** H264 Lossless GPU/Hardware based compression.\n Average size: 25% of RAW \n Provides a SSIM/PSNR result (vs RAW) >= 99.9%. \note Requires a NVIDIA GPU. */
	SL_SVO_COMPRESSION_MODE_H264_LOSSLESS = 3,
	/** H265 Lossless GPU/Hardware based compression.\n Average size: 25% of RAW \n Provides a SSIM/PSNR result (vs RAW) >= 99.9%. \note Requires a NVIDIA GPU. */
	SL_SVO_COMPRESSION_MODE_H265_LOSSLESS = 4;

/**
\brief Lists available matrix formats.
\note Matrix type depends on image or measure type.
\note For the dependencies, see \ref SL_VIEW and \ref SL_MEASURE.
 */
/** enum SL_MAT_TYPE */
public static final int
	/** 1-channel matrix of float*/
	SL_MAT_TYPE_F32_C1 = 0,
	/** 2-channel matrix of float*/
	SL_MAT_TYPE_F32_C2 = 1,
	/** 3-channel matrix of float*/
	SL_MAT_TYPE_F32_C3 = 2,
	/** 4-channel matrix of float*/
	SL_MAT_TYPE_F32_C4 = 3,
	/** 1-channel matrix of unsigned char*/
	SL_MAT_TYPE_U8_C1 = 4,
	/** 2-channel matrix of unsigned char*/
	SL_MAT_TYPE_U8_C2 = 5,
	/** 3-channel matrix of unsigned char*/
	SL_MAT_TYPE_U8_C3 = 6,
	/** 4-channel matrix of unsigned char*/
	SL_MAT_TYPE_U8_C4 = 7,
	/** 1-channel matrix of unsigned short*/
	SL_MAT_TYPE_U16_C1 = 8,
	/** 4-channel matrix of signed char*/
	SL_MAT_TYPE_S8_C4 = 9;

/**
\brief List available object subclasses.
<p>
Given as hint, when using object tracking an object can change of \ref SL_OBJECT_SUBCLASS while keeping the same \ref SL_OBJECT_CLASS
(i.e.: frame n: \ref SL_OBJECT_SUBCLASS_MOTORBIKE, frame n+1: \ref SL_OBJECT_SUBCLASS_BICYCLE).
*/
/** enum SL_OBJECT_SUBCLASS */
public static final int
	/** \ref SL_OBJECT_CLASS_PERSON */
	SL_OBJECT_SUBCLASS_PERSON = 0,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_BICYCLE = 1,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_CAR = 2,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_MOTORBIKE = 3,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_BUS = 4,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_TRUCK = 5,
	/** \ref SL_OBJECT_CLASS_VEHICLE */
	SL_OBJECT_SUBCLASS_BOAT = 6,
	/** \ref SL_OBJECT_CLASS_BAG */
	SL_OBJECT_SUBCLASS_BACKPACK = 7,
	/** \ref SL_OBJECT_CLASS_BAG */
	SL_OBJECT_SUBCLASS_HANDBAG = 8,
	/** \ref SL_OBJECT_CLASS_BAG */
	SL_OBJECT_SUBCLASS_SUITCASE = 9,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_BIRD = 10,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_CAT = 11,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_DOG = 12,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_HORSE = 13,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_SHEEP = 14,
	/** \ref SL_OBJECT_CLASS_ANIMAL */
	SL_OBJECT_SUBCLASS_COW = 15,
	/** \ref SL_OBJECT_CLASS_ELECTRONICS */
	SL_OBJECT_SUBCLASS_CELLPHONE = 16,
	/** \ref SL_OBJECT_CLASS_ELECTRONICS */
	SL_OBJECT_SUBCLASS_LAPTOP = 17,
	/** \ref SL_OBJECT_CLASS_FRUIT_VEGETABLE */
	SL_OBJECT_SUBCLASS_BANANA = 18,
	/** \ref SL_OBJECT_CLASS_FRUIT_VEGETABLE */
	SL_OBJECT_SUBCLASS_APPLE = 19,
	/** \ref SL_OBJECT_CLASS_FRUIT_VEGETABLE */
	SL_OBJECT_SUBCLASS_ORANGE = 20,
	/** \ref SL_OBJECT_CLASS_FRUIT_VEGETABLE */
	SL_OBJECT_SUBCLASS_CARROT = 21,
	/** \ref SL_OBJECT_CLASS_PERSON */
	SL_OBJECT_SUBCLASS_PERSON_HEAD = 22,
	/** \ref SL_OBJECT_CLASS_SPORT*/
	SL_OBJEC_SUBCLASS_SPORTSBALL = 23;

/**
\brief Lists the different states of an object's actions.
 */
/** enum SL_OBJECT_ACTION_STATE */
public static final int
	/** The object is staying static. */
	SL_OBJECT_ACTION_STATE_IDLE = 0,
	/** The object is moving. */
	SL_OBJECT_ACTION_STATE_MOVING = 1;

/**
\brief Lists available models for the object detection module.
 */
/** enum SL_OBJECT_DETECTION_MODEL */
public static final int
	/** Any objects, bounding box based. */
	SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_FAST = 0,
	/** Any objects, bounding box based, compromise between accuracy and speed. */
	SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_MEDIUM = 1,
	/** Any objects, bounding box based, more accurate but slower than the base model. */
	SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_ACCURATE = 2,
	/** Bounding box detector specialized in person heads particularly well suited for crowded environments. The person localization is also improved. */
	SL_OBJECT_DETECTION_MODEL_PERSON_HEAD_BOX_FAST = 3,
	/** Bounding box detector specialized in person heads, particularly well suited for crowded environments. The person localization is also improved, more accurate but slower than the base model.*/
	SL_OBJECT_DETECTION_MODEL_PERSON_HEAD_BOX_ACCURATE = 4,
	/** For external inference, using your own custom model and/or frameworks. This mode disables the internal inference engine, the 2D bounding box detection must be provided. */
	SL_OBJECT_DETECTION_MODEL_CUSTOM_BOX_OBJECTS = 5;
/**
\brief Lists available models for the body tracking module.
*/
/** enum SL_BODY_TRACKING_MODEL */
public static final int
	/** Keypoints based, specific to human skeleton, real time performance even on Jetson or low end GPU cards. */
	SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST = 0,
	/** Keypoints based, specific to human skeleton, compromise between accuracy and speed. */
	SL_BODY_TRACKING_MODEL_HUMAN_BODY_MEDIUM = 1,
	/** Keypoints based, specific to human skeleton, state of the art accuracy, requires powerful GPU. */
	SL_BODY_TRACKING_MODEL_HUMAN_BODY_ACCURATE = 2;

/**
 \brief Lists available  AI models.
*/
/** enum SL_AI_MODELS */
public static final int
	/** Related to \ref SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_FAST*/
	SL_AI_MODELS_MULTI_CLASS_DETECTION = 0,
	/** Related to \ref SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_MEDIUM*/
	SL_AI_MODELS_MULTI_CLASS_MEDIUM_DETECTION = 1,
	/** Related to \ref SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_ACCURATE*/
	SL_AI_MODELS_MULTI_CLASS_ACCURATE_DETECTION = 2,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	SL_AI_MODELS_HUMAN_BODY_FAST_DETECTION = 3,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_MEDIUM*/
	SL_AI_MODELS_HUMAN_BODY_MEDIUM_DETECTION = 4,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_ACCURATE*/
	SL_AI_MODELS_HUMAN_BODY_ACCURATE_DETECTION = 5,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	SL_AI_MODELS_HUMAN_BODY_38_FAST_DETECTION = 6,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	SL_AI_MODELS_HUMAN_BODY_38_MEDIUM_DETECTION = 7,
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	SL_AI_MODELS_HUMAN_BODY_38_ACCURATE_DETECTION = 8,
	//SL_AI_MODELS_HUMAN_BODY_70_FAST_DETECTION, /**< Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	//SL_AI_MODELS_HUMAN_BODY_70_MEDIUM_DETECTION, /**< Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_MEDIUM*/
	//SL_AI_MODELS_HUMAN_BODY_70_ACCURATE_DETECTION, /**< Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_ACCURATE*/
	/** Related to \ref SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST*/
	SL_AI_MODELS_PERSON_HEAD_DETECTION = 9,
	/** Related to \ref SL_OBJECT_DETECTION_MODEL_PERSON_HEAD_BOX_ACCURATE*/
	SL_AI_MODELS_PERSON_HEAD_ACCURATE_DETECTION = 10,
	/** Related to \ref SL_BatchParameters.enable*/
	SL_AI_MODELS_REID_ASSOCIATION = 11,
	/** Related to \ref SL_DEPTH_MODE_NEURAL*/
	SL_AI_MODELS_NEURAL_DEPTH = 12,
	/** Related to \ref SL_DEPTH_MODE_NEURAL_PLUS*/
	SL_AI_MODELS_NEURAL_PLUS_DEPTH = 13,
	SL_AI_MODELS_LAST = 14;

/**
\brief Lists supported bounding box preprocessing.
 */
/** enum SL_OBJECT_FILTERING_MODE */
public static final int
	/** The ZED SDK will not apply any preprocessing to the detected objects. */
	SL_OBJECT_FILTERING_MODE_NONE = 0,
	/** The ZED SDK will remove objects that are in the same 3D position as an already tracked object (independent of class id). */
	SL_OBJECT_FILTERING_MODE_NMS_3D = 1,
	/** The ZED SDK will remove objects that are in the same 3D position as an already tracked object of the same class id. */
	SL_OBJECT_FILTERING_MODE_NMS_3D_PER_CLASS = 2;


/**
\brief Lists supported skeleton body models.
*/
/** enum SL_BODY_FORMAT */
public static final int
	/**
	 * \brief 18-keypoint model
	 * \n Basic body model
	 */
	SL_BODY_FORMAT_BODY_18 = 0,
	/**
	 * \brief 34-keypoint model
	 * \note Requires body fitting enabled.
	 */
	SL_BODY_FORMAT_BODY_34 = 1,
	/**
	 * \brief 38-keypoint model
	 * \n Including simplified face, hands and feet.
	 *  \note Early Access
	 */
	SL_BODY_FORMAT_BODY_38 = 2;

// #if 0
// #endif
/**
\brief Lists supported models for skeleton keypoints selection.
*/
/** enum SL_BODY_KEYPOINTS_SELECTION */
public static final int
	/**
	 * \brief Full keypoint model
	 */
	SL_BODY_KEYPOINTS_SELECTION_FULL = 0,
	/**
	 * \brief Upper body keypoint model
	 * \n Will output only upper body (from hip).
	 */
	SL_BODY_KEYPOINTS_SELECTION_UPPER_BODY = 1;
	/**
	 * \brief Hands only
	 */
	//SL_BODY_KEYPOINTS_SELECTION_HAND


/**
 * \brief Semantic of human body parts and order of \ref SL_BodyData.keypoint for \ref SL_BODY_FORMAT_BODY_18.
 */
/** enum SL_BODY_18_PARTS */
public static final int
	/** 0*/
	SL_BODY_18_PARTS_NOSE = 0,
	/** 1*/
	SL_BODY_18_PARTS_NECK = 1,
	/** 2*/
	SL_BODY_18_PARTS_RIGHT_SHOULDER = 2,
	/** 3*/
	SL_BODY_18_PARTS_RIGHT_ELBOW = 3,
	/** 4*/
	SL_BODY_18_PARTS_RIGHT_WRIST = 4,
	/** 5*/
	SL_BODY_18_PARTS_LEFT_SHOULDER = 5,
	/** 6*/
	SL_BODY_18_PARTS_LEFT_ELBOW = 6,
	/** 7*/
	SL_BODY_18_PARTS_LEFT_WRIST = 7,
	/** 8*/
	SL_BODY_18_PARTS_RIGHT_HIP = 8,
	/** 9*/
	SL_BODY_18_PARTS_RIGHT_KNEE = 9,
	/** 10*/
	SL_BODY_18_PARTS_RIGHT_ANKLE = 10,
	/** 11*/
	SL_BODY_18_PARTS_LEFT_HIP = 11,
	/** 12*/
	SL_BODY_18_PARTS_LEFT_KNEE = 12,
	/** 13*/
	SL_BODY_18_PARTS_LEFT_ANKLE = 13,
	/** 14*/
	SL_BODY_18_PARTS_RIGHT_EYE = 14,
	/** 15*/
	SL_BODY_18_PARTS_LEFT_EYE = 15,
	/** 16*/
	SL_BODY_18_PARTS_RIGHT_EAR = 16,
	/** 17*/
	SL_BODY_18_PARTS_LEFT_EAR = 17,
	SL_BODY_18_PARTS_LAST = 18;

/**
 * \brief Semantic of human body parts and order of \ref SL_BodyData.keypoint for \ref SL_BODY_FORMAT_BODY_34.
 */
/** enum SL_BODY_34_PARTS */
public static final int
	/** 0*/
	SL_BODY_34_PARTS_PELVIS = 0,
	/** 1*/
	SL_BODY_34_PARTS_NAVAL_SPINE = 1,
	/** 2*/
	SL_BODY_34_PARTS_CHEST_SPINE = 2,
	/** 3*/
	SL_BODY_34_PARTS_NECK = 3,
	/** 4*/
	SL_BODY_34_PARTS_LEFT_CLAVICLE = 4,
	/** 5*/
	SL_BODY_34_PARTS_LEFT_SHOULDER = 5,
	/** 6*/
	SL_BODY_34_PARTS_LEFT_ELBOW = 6,
	/** 7*/
	SL_BODY_34_PARTS_LEFT_WRIST = 7,
	/** 8*/
	SL_BODY_34_PARTS_LEFT_HAND = 8,
	/** 9*/
	SL_BODY_34_PARTS_LEFT_HANDTIP = 9,
	/** 10*/
	SL_BODY_34_PARTS_LEFT_THUMB = 10,
	/** 11*/
	SL_BODY_34_PARTS_RIGHT_CLAVICLE = 11,
	/** 12*/
	SL_BODY_34_PARTS_RIGHT_SHOULDER = 12,
	/** 13*/
	SL_BODY_34_PARTS_RIGHT_ELBOW = 13,
	/** 14*/
	SL_BODY_34_PARTS_RIGHT_WRIST = 14,
	/** 15*/
	SL_BODY_34_PARTS_RIGHT_HAND = 15,
	/** 16*/
	SL_BODY_34_PARTS_RIGHT_HANDTIP = 16,
	/** 17*/
	SL_BODY_34_PARTS_RIGHT_THUMB = 17,
	/** 18*/
	SL_BODY_34_PARTS_LEFT_HIP = 18,
	/** 19*/
	SL_BODY_34_PARTS_LEFT_KNEE = 19,
	/** 20*/
	SL_BODY_34_PARTS_LEFT_ANKLE = 20,
	/** 21*/
	SL_BODY_34_PARTS_LEFT_FOOT = 21,
	/** 22*/
	SL_BODY_34_PARTS_RIGHT_HIP = 22,
	/** 23*/
	SL_BODY_34_PARTS_RIGHT_KNEE = 23,
	/** 24*/
	SL_BODY_34_PARTS_RIGHT_ANKLE = 24,
	/** 25*/
	SL_BODY_34_PARTS_RIGHT_FOOT = 25,
	/** 26*/
	SL_BODY_34_PARTS_HEAD = 26,
	/** 27*/
	SL_BODY_34_PARTS_NOSE = 27,
	/** 28*/
	SL_BODY_34_PARTS_LEFT_EYE = 28,
	/** 29*/
	SL_BODY_34_PARTS_LEFT_EAR = 29,
	/** 30*/
	SL_BODY_34_PARTS_RIGHT_EYE = 30,
	/** 31*/
	SL_BODY_34_PARTS_RIGHT_EAR = 31,
	/** 32*/
	SL_BODY_34_PARTS_LEFT_HEEL = 32,
	/** 33*/
	SL_BODY_34_PARTS_RIGHT_HEEL = 33,
	SL_BODY_34_PARTS_LAST = 34;


/**
 * \brief Semantic of human body parts and order of \ref SL_BodyData.keypoint for \ref SL_BODY_FORMAT_BODY_38.
 */
/** enum SL_BODY_38_PARTS */
public static final int
	/** 0*/
	SL_BODY_38_PARTS_PELVIS = 0,
	/** 1*/
	SL_BODY_38_PARTS_SPINE_1 = 1,
	/** 2*/
	SL_BODY_38_PARTS_SPINE_2 = 2,
	/** 3*/
	SL_BODY_38_PARTS_SPINE_3 = 3,
	/** 4*/
	SL_BODY_38_PARTS_NECK = 4,
	/** 5*/
	SL_BODY_38_PARTS_NOSE = 5,
	/** 6*/
	SL_BODY_38_PARTS_LEFT_EYE = 6,
	/** 7*/
	SL_BODY_38_PARTS_RIGHT_EYE = 7,
	/** 8*/
	SL_BODY_38_PARTS_LEFT_EAR = 8,
	/** 9*/
	SL_BODY_38_PARTS_RIGHT_EAR = 9,
	/** 10*/
	SL_BODY_38_PARTS_LEFT_CLAVICLE = 10,
	/** 11*/
	SL_BODY_38_PARTS_RIGHT_CLAVICLE = 11,
	/** 12*/
	SL_BODY_38_PARTS_LEFT_SHOULDER = 12,
	/** 13*/
	SL_BODY_38_PARTS_RIGHT_SHOULDER = 13,
	/** 14*/
	SL_BODY_38_PARTS_LEFT_ELBOW = 14,
	/** 15*/
	SL_BODY_38_PARTS_RIGHT_ELBOW = 15,
	/** 16*/
	SL_BODY_38_PARTS_LEFT_WRIST = 16,
	/** 17*/
	SL_BODY_38_PARTS_RIGHT_WRIST = 17,
	/** 18*/
	SL_BODY_38_PARTS_LEFT_HIP = 18,
	/** 19*/
	SL_BODY_38_PARTS_RIGHT_HIP = 19,
	/** 20*/
	SL_BODY_38_PARTS_LEFT_KNEE = 20,
	/** 21*/
	SL_BODY_38_PARTS_RIGHT_KNEE = 21,
	/** 22*/
	SL_BODY_38_PARTS_LEFT_ANKLE = 22,
	/** 23*/
	SL_BODY_38_PARTS_RIGHT_ANKLE = 23,
	/** 24*/
	SL_BODY_38_PARTS_LEFT_BIG_TOE = 24,
	/** 25*/
	SL_BODY_38_PARTS_RIGHT_BIG_TOE = 25,
	/** 26*/
	SL_BODY_38_PARTS_LEFT_SMALL_TOE = 26,
	/** 27*/
	SL_BODY_38_PARTS_RIGHT_SMALL_TOE = 27,
	/** 28*/
	SL_BODY_38_PARTS_LEFT_HEEL = 28,
	/** 29*/
	SL_BODY_38_PARTS_RIGHT_HEEL = 29,
	// Hands
	/** 30*/
	SL_BODY_38_PARTS_LEFT_HAND_THUMB_4 = 30,
	/** 31*/
	SL_BODY_38_PARTS_RIGHT_HAND_THUMB_4 = 31,
	/** 32*/
	SL_BODY_38_PARTS_LEFT_HAND_INDEX_1 = 32,
	/** 33*/
	SL_BODY_38_PARTS_RIGHT_HAND_INDEX_1 = 33,
	/** 34*/
	SL_BODY_38_PARTS_LEFT_HAND_MIDDLE_4 = 34,
	/** 35*/
	SL_BODY_38_PARTS_RIGHT_HAND_MIDDLE_4 = 35,
	/** 36*/
	SL_BODY_38_PARTS_LEFT_HAND_PINKY_1 = 36,
	/** 37*/
	SL_BODY_38_PARTS_RIGHT_HAND_PINKY_1 = 37,
	SL_BODY_38_PARTS_LAST = 38;

// #if 0
// #endif

/** enum SL_MODULE */
public static final int
	/** All modules*/
	SL_MODULE_ALL = 0,
	SL_MODULE_DEPTH = 1,
	SL_MODULE_POSITIONAL_TRACKING = 2,
	SL_MODULE_OBJECT_DETECTION = 3,
	SL_MODULE_BODY_TRACKING = 4,
	SL_MODULE_SPATIAL_MAPPING = 5,
	SL_MODULE_LAST = 6;

/**
* \brief Lists the types of possible position outputs.
*/
/** enum SL_POSITION_TYPE */
public static final int
	/** The output position will be the raw position data. */
	SL_POSITION_TYPE_RAW = 0,
	/** The output position will be the fused position projected into the requested camera repository. */
	SL_POSITION_TYPE_FUSION = 1,
	/**\cond SHOWHIDDEN  */
	SL_POSITION_TYPE_LAST = 2;
	/**\endcond */
// Targeting ../SL_Resolution.java


// Targeting ../SL_InitParameters.java


// Targeting ../SL_RuntimeParameters.java


// Targeting ../SL_DeviceProperties.java


// Targeting ../SL_CameraParameters.java


// Targeting ../SL_CalibrationParameters.java


// Targeting ../SL_SensorParameters.java


// Targeting ../SL_CameraConfiguration.java


// Targeting ../SL_SensorsConfiguration.java


// Targeting ../SL_CameraInformation.java


// Targeting ../SL_PositionalTrackingParameters.java


// Targeting ../SL_RegionOfInterestParameters.java


// Targeting ../SL_PlaneDetectionParameters.java


// Targeting ../SL_RecordingStatus.java


// Targeting ../SL_RecordingParameters.java


// Targeting ../SL_SVOData.java


// Targeting ../SL_StreamingParameters.java


// Targeting ../SL_StreamingProperties.java


// Targeting ../SL_SpatialMappingParameters.java




// #if WITH_OBJECT_DETECTION
public static final int MAX_NUMBER_OBJECT = 75;
public static final int MAX_TRAJECTORY_SIZE = 200;
// Targeting ../SL_BatchParameters.java


// Targeting ../SL_AI_Model_status.java


// Targeting ../SL_ObjectDetectionParameters.java



/**
\brief Lists available object classes.
 */
/** enum SL_OBJECT_CLASS */
public static final int
	/** For people detection */
	SL_OBJECT_CLASS_PERSON = 0,
	/** For vehicle detection (cars, trucks, buses, motorcycles, etc.) */
	SL_OBJECT_CLASS_VEHICLE = 1,
	/** For bag detection (backpack, handbag, suitcase, etc.) */
	SL_OBJECT_CLASS_BAG = 2,
	/** For animal detection (cow, sheep, horse, dog, cat, bird, etc.) */
	SL_OBJECT_CLASS_ANIMAL = 3,
	/** For electronic device detection (cellphone, laptop, etc.) */
	SL_OBJECT_CLASS_ELECTRONICS = 4,
	/** For fruit and vegetable detection (banana, apple, orange, carrot, etc.) */
	SL_OBJECT_CLASS_FRUIT_VEGETABLE = 5,
	/** For sport-related object detection (sport ball, etc.) */
	SL_OBJECT_CLASS_SPORT = 6,
	SL_OBJECT_CLASS_LAST = 7;
// Targeting ../SL_ObjectDetectionRuntimeParameters.java


// Targeting ../SL_BodyTrackingParameters.java


// Targeting ../SL_BodyTrackingRuntimeParameters.java


// Targeting ../SL_ObjectData.java


// Targeting ../SL_CustomBoxObjectData.java


// Targeting ../SL_Objects.java


// Targeting ../SL_BodyData.java


// Targeting ../SL_Bodies.java


// Targeting ../SL_ObjectsBatch.java


// Targeting ../SL_Rect.java


// Targeting ../SL_InputType.java




////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// FUSION API /////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
\enum SL_FUSION_ERROR_CODE
\brief Lists the types of error that can be raised by the Fusion.
*/
/** enum SL_FUSION_ERROR_CODE */
public static final int
	/** Ingested covariance data must vary between ingest */
	SL_FUSION_ERROR_CODE_GNSS_DATA_COVARIANCE_MUST_VARY = -8,
	/** The senders are using different body formats.\n Consider changing them. */
	SL_FUSION_ERROR_CODE_BODY_FORMAT_MISMATCH = -7,
	/** The following module was not enabled. */
	SL_FUSION_ERROR_CODE_MODULE_NOT_ENABLED = -6,
	/** Some sources are provided by SVO and others by LIVE stream. */
	SL_FUSION_ERROR_CODE_SOURCE_MISMATCH = -5,
	/** Connection timed out. Unable to reach the sender.\n Verify the sender's IP/port. */
	SL_FUSION_ERROR_CODE_CONNECTION_TIMED_OUT = -4,
	/** Intra-process shared memory allocation issue.\n Multiple connections to the same data. */
	SL_FUSION_ERROR_CODE_MEMORY_ALREADY_USED = -3,
	/** The provided IP address format is incorrect.\n Please provide the IP in the format 'a.b.c.d', where (a, b, c, d) are numbers between 0 and 255. */
	SL_FUSION_ERROR_CODE_INVALID_IP_ADDRESS = -2,
	/** Standard code for unsuccessful behavior. */
	SL_FUSION_ERROR_CODE_FAILURE = -1,
	/** Standard code for successful behavior. */
	SL_FUSION_ERROR_CODE_SUCCESS = 0,
	/** Significant differences observed between sender's FPS. */
	SL_FUSION_ERROR_CODE_FUSION_INCONSISTENT_FPS = 1,
	/** At least one sender has an FPS lower than 10 FPS. */
	SL_FUSION_ERROR_CODE_FUSION_FPS_TOO_LOW = 2,
	/** Problem detected with the ingested timestamp.\n Sample data will be ignored. */
	SL_FUSION_ERROR_CODE_INVALID_TIMESTAMP = 3,
	/** Problem detected with the ingested covariance.\n Sample data will be ignored. */
	SL_FUSION_ERROR_CODE_INVALID_COVARIANCE = 4,
	/** All data from all sources has been consumed.\n No new data is available for processing. */
	SL_FUSION_ERROR_CODE_NO_NEW_DATA_AVAILABLE = 5;

/**
\enum SL_SENDER_ERROR_CODE
\brief Lists the types of error that can be raised during the Fusion by senders.
*/
/** enum SL_SENDER_ERROR_CODE */
public static final int
	/** The sender has been disconnected.*/
	SL_SENDER_ERROR_CODE_DISCONNECTED = -1,
	/** Standard code for successful behavior.*/
	SL_SENDER_ERROR_CODE_SUCCESS = 0,
	/** The sender encountered a grab error.*/
	SL_SENDER_ERROR_CODE_GRAB_ERROR = 1,
	/** The sender does not run with a constant frame rate.*/
	SL_SENDER_ERROR_CODE_INCONSISTENT_FPS = 2,
	/** The frame rate of the sender is lower than 10 FPS.*/
	SL_SENDER_ERROR_CODE_FPS_TOO_LOW = 3;

/**
\enum SL_COMM_TYPE
\brief Lists the different types of communications available for Fusion module.
*/
/** enum SL_COMM_TYPE */
public static final int
	/** The sender and receiver are on the same local network and communicate by RTP.\n The communication can be affected by the local network load.*/
	SL_COMM_TYPE_LOCAL_NETWORK = 0,
	/** Both sender and receiver are declared by the same process and can be in different threads.\n This type of communication is optimized.*/
	SL_COMM_TYPE_INTRA_PROCESS = 1;

/**
 \brief Class representing the fix quality of GNSS signal.
 */
/** enum SL_GNSS_STATUS */
public static final int
	/** No GNSS fix data is available. */
	SL_GNSS_STATUS_UNKNOWN = 0,
	/** Single Point Positioning */
	SL_GNSS_STATUS_SINGLE = 1,
	/** Differential GNSS */
	SL_GNSS_STATUS_DGNSS = 2,
	/** Real-Time Kinematic (RTK) GNSS fix in fixed mode. */
	SL_GNSS_STATUS_RTK_FIX = 3,
	/** Real-Time Kinematic (RTK) GNSS fix in float mode. */
	SL_GNSS_STATUS_RTK_FLOAT = 4,
	/** Precise Positioning Service */
	SL_GNSS_STATUS_PPS = 5;

/** enum SL_GNSS_MODE */
public static final int
	/** No GNSS fix data is available. */
	SL_GNSS_MODE_UNKNOWN = 0,
	/** No GNSS fix is available. */
	SL_GNSS_MODE_NO_FIX = 1,
	/** 2D GNSS fix, providing latitude and longitude coordinates but without altitude information. */
	SL_GNSS_MODE_FIX_2D = 2,
	/** 3D GNSS fix, providing latitude, longitude, and altitude coordinates. */
	SL_GNSS_MODE_FIX_3D = 3;

/**
 \brief Class containing the current GNSS fusion status.
 */
/** enum SL_GNSS_FUSION_STATUS */
public static final int
	/** The GNSS fusion module is calibrated and working successfully. */
	SL_GNSS_FUSION_STATUS_OK = 0,
	/** The GNSS fusion module is not enabled. */
	SL_GNSS_FUSION_STATUS_OFF = 1,
	/** Calibration of the GNSS/VIO fusion module is in progress. */
	SL_GNSS_FUSION_STATUS_CALIBRATION_IN_PROGRESS = 2,
	/** Re-alignment of GNSS/VIO data is in progress, leading to potentially inaccurate global position. */
	SL_GNSS_FUSION_STATUS_RECALIBRATION_IN_PROGRESS = 3;
// Targeting ../SL_FusedPositionalTrackingStatus.java


// Targeting ../SL_CommunicationParameters.java


// Targeting ../SL_FusionConfiguration.java


// Targeting ../SL_InitFusionParameters.java


// Targeting ../SL_BodyTrackingFusionParameters.java


// Targeting ../SL_BodyTrackingFusionRuntimeParameters.java


// Targeting ../SL_CameraIdentifier.java


// Targeting ../SL_CameraMetrics.java


// Targeting ../SL_FusionMetrics.java


// Targeting ../SL_GNSSData.java


// Targeting ../SL_LatLng.java


// Targeting ../SL_GeoPose.java


// Targeting ../SL_ECEF.java


// Targeting ../SL_UTM.java


// Targeting ../SL_GNSSCalibrationParameters.java


// Targeting ../SL_PositionalTrackingFusionParameters.java



// #if 0
// #endif

// #endif


// Parsed from zed_interface.h

// #ifndef __INTERFACE_ZED_H
// #define __INTERFACE_ZED_H

// #include "types_c.h"
// #include <stdbool.h>
// #include <cuda.h>
// #include <cuda_runtime.h>

/**
 * \file
 * */

 //#define DEBUG
// #ifdef _WIN32
// #ifdef INTERFACE_NOEXPORT
// #define INTERFACE_API
// #else
// #ifdef INTERFACE_EXPORT
// #define INTERFACE_API __declspec(dllexport)
// #else
// #define INTERFACE_API __declspec(dllimport)
// #endif
// #endif
// #else
// #define INTERFACE_API
// #endif

// #ifdef __cplusplus
// #endif


    /**
    \brief Forces unload of all instances.
    */
    public static native void sl_unload_all_instances();

    /**
    \brief Forces unload of one instance.
    @param camera_id : id of the instance to unload.
    */
    public static native void sl_unload_instance(int camera_id);

    /**
    \brief Checks usb devices connected.
    *param device : type of device to find.
    @return true if connected.
    */
    public static native @Cast("bool") boolean sl_find_usb_device(@Cast("USB_DEVICE") int device);

    /**
    * \brief Creates a camera with resolution mode, fps and id for linux.
    * @param camera_id : id of the camera to be added.
    * @param verbose : Enable verbose mode.
    * @return true if the camera has been created successfully.
    */
    public static native @Cast("bool") boolean sl_create_camera(int camera_id);

    /**
    \brief Reports if the camera has been successfully opened.
    @param camera_id : Id of the camera.
    @return true if the ZED camera is already setup, otherwise false.
    */
    public static native @Cast("bool") boolean sl_is_opened(int camera_id);

    /**
    \brief Opens the ZED camera from the provided SL_InitParameters.
    @param camera_id : Id of the camera to open.
    @param init_parameters : A structure containing all the initial parameters. Default: a preset of SL_InitParameters.
    @param serial_number : Serial number of the camera to open.
    @param path_svo : Filename of the svo to read (for SVO input).
    @param ip : IP of the camera to open (for Stream input).
    @param stream_port : Port of the camera to open (for Stream input).
    @param output_file : ZED SDK verbose log file. Redirect the SDK verbose message to the file.
    @param opt_settings_path[optional] : Settings path.
    @param opencv_calib_path[optional] : openCV calibration file.
    @return An error code giving information about the internal process. If \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" (0) is returned, the camera is ready to use. Every other code indicates an error and the program should be stopped.
    */
    public static native int sl_open_camera(int camera_id, SL_InitParameters init_parameters, @Cast("const unsigned int") int serial_number,  @Cast("const char*") BytePointer path_svo, @Cast("const char*") BytePointer ip, int stream_port, @Cast("const char*") BytePointer output_file, @Cast("const char*") BytePointer opt_settings_path, @Cast("const char*") BytePointer opencv_calib_path);
    public static native int sl_open_camera(int camera_id, SL_InitParameters init_parameters, @Cast("const unsigned int") int serial_number,  String path_svo, String ip, int stream_port, String output_file, String opt_settings_path, String opencv_calib_path);


    /**
    \brief Set this camera as a data provider for the Fusion module.
    <p>
    Metadata is exchanged with the Fusion.
    @param camera_id : Id of the camera instance.
    @param configuration : A structure containing all the initial parameters. Default: a preset of \ref SL_CommunicationParameters.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_start_publishing(int camera_id, SL_CommunicationParameters comm_params);

    /**
    \brief Set this camera as normal camera(without data providing).
    \n Stop to send camera data to fusion.
    @return \ref SUCCESS if everything went fine, \ref SL_ERROR_CODE_FAILURE otherwise
    */
    public static native @Cast("SL_ERROR_CODE") int sl_stop_publishing(int camera_id);

    /**
    \brief Gets the Camera-created CUDA context for sharing it with other CUDA-capable libraries.
    <p>
    This can be useful for sharing GPU memories.
    @param camera_id : Id of the camera instance.
    */
    public static native CUctx_st sl_get_cuda_context(int camera_id);

    /**
    \brief Returns the SL_InitParameters used.
    <p>
    It corresponds to the structure given as argument to the sl_open_camera() function.
    @param camera_id : Id of the camera instance.
    @return SL_InitParameters containing the parameters used to initialize the camera.
    */
    public static native SL_InitParameters sl_get_init_parameters(int camera_id);

    /**
    \brief Returns the SL_RuntimeParameters used.
    <p>
    It corresponds to the structure given as argument to the sl_grab() function.
    @param camera_id : id of the camera instance.
    @return SL_RuntimeParameters containing the parameters that define the behavior of the \ref sl_grab function.
    */
    public static native SL_RuntimeParameters sl_get_runtime_parameters(int camera_id);

    /**
    \brief Returns the \ref SL_PositionalTrackingParameters used.
    
    It corresponds to the structure given as argument to the \ref sl_enable_positional_tracking() method.
    @param camera_id : Id of the camera instance.
    @return \ref SL_PositionalTrackingParameters containing the parameters used for positional tracking initialization.
    */
    public static native SL_PositionalTrackingParameters sl_get_positional_tracking_parameters(int camera_id);

    /**
    \brief Close an opened camera and disable the textures.
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_close_camera(int camera_id);

    /**
    \brief Defines a region of interest to focus on for all the SDK, discarding other parts.
    @param camera_id : Id of the camera instance.
    @param roi_mask : The matrix defining the requested region of interest, pixels lower than 127 will be discarded from all modules: depth, positional tracking, etc. If empty, set all pixels as valid. The mask can be either at lower or higher resolution than the current images.
    @param module: Apply the ROI to a list of SDK module, all by default.
    @return An \ref SL_ERROR_CODE if something went wrong.
    \note The function support \ref SL_MAT_TYPE "SL_MAT_TYPE_U8_C1" / \ref SL_MAT_TYPE "SL_MAT_TYPE_UU8_C3" / \ref SL_MAT_TYPE "SL_MAT_TYPE_UU8_C4" images type.
     */
    public static native int sl_set_region_of_interest(int camera_id, Pointer roi_mask, @Cast("bool*") BoolPointer module);
    public static native int sl_set_region_of_interest(int camera_id, Pointer roi_mask, @Cast("bool*") boolean[] module);

    /**
    \brief Get the previously set or computed region of interest.
    @param camera_id : Id of the camera instance.
    @param roi_mask: The \ref Mat returned.
    @param image_size: The optional size of the returned mask.
    @param module: Specify which module to get the ROI.
    @return An \ref SL_ERROR_CODE if something went wrong.
     */
    public static native int sl_get_region_of_interest(int camera_id, Pointer roi_mask, int width, int height, @Cast("SL_MODULE") int module);
    /**
    \brief Start the auto detection of a region of interest to focus on for all the SDK, discarding other parts.
    This detection is based on the general motion of the camera combined with the motion in the scene.
    The camera must move for this process, an internal motion detector is used, based on the Positional Tracking module.
    It requires a few hundreds frames of motion to compute the mask.
    <p>
    @param roi_param: The \ref SL_RegionOfInterestParameters defining parameters for the detection
    <p>
    \note This module is expecting a static portion, typically a fairly close vehicle hood at the bottom of the image.
     This module may not work correctly or detect incorrect background area, especially with slow motion, if there's no static element.
     This module work asynchronously, the status can be obtained using \ref sl_get_region_of_interest_auto_detection_status(), the result is either auto applied,
     or can be retrieve using \ref sl_get_region_of_interest function.
    <p>
    @return An \ref SL_ERROR_CODE if something went wrong.
     */
    public static native int sl_start_region_of_interest_auto_detection(int camera_id, SL_RegionOfInterestParameters roi_param);
    /**
    \brief Return the status of the automatic Region of Interest Detection
     The automatic Region of Interest Detection is enabled by using \ref sl_start_region_of_interest_auto_detection
     @param camera_id : Id of the camera instance.
    @return \ref SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE the status
     */
    public static native @Cast("SL_REGION_OF_INTEREST_AUTO_DETECTION_STATE") int sl_get_region_of_interest_auto_detection_status(int camera_id);
    /**
    \brief Grabs the latest images from the camera.
    @param camera_id : Id of the camera instance.
    @param runtime : A structure containing all the runtime parameters. Default: a preset of SL_RuntimeParameters.
    @return An error code giving information about the internal process. \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the method succeeded.
     */
    public static native int sl_grab(int camera_id, SL_RuntimeParameters runtime);

    /**
    \brief Lists all the connected devices with their associated information.
    <p>
    This method lists all the cameras available and provides their serial number, models and other information.
    @param device_list [Out] : The devices properties for each connected camera.
    @param nb_devices [Out] : The number of cameras connected.
     */
    public static native void sl_get_device_list(SL_DeviceProperties device_list, IntPointer nb_devices);
    public static native void sl_get_device_list(SL_DeviceProperties device_list, IntBuffer nb_devices);
    public static native void sl_get_device_list(SL_DeviceProperties device_list, int[] nb_devices);

    /**
    \brief List all the streaming devices with their associated information.
    @param device_list [Out] : The devices properties for each connected camera.
    @param nb_devices  [Out]: The number of cameras connected.
    @return The streaming properties for each connected camera.
     */
    public static native void sl_get_streaming_device_list(SL_StreamingProperties streaming_device_list, IntPointer nb_devices);
    public static native void sl_get_streaming_device_list(SL_StreamingProperties streaming_device_list, IntBuffer nb_devices);
    public static native void sl_get_streaming_device_list(SL_StreamingProperties streaming_device_list, int[] nb_devices);

    /**
    \brief Performs a hardware reset of the ZED 2 and the ZED 2i.
    @param sn : Serial number of the camera to reset, or 0 to reset the first camera detected.
    @param fullReboot : Perform a full reboot (sensors and video modules) if true, otherwise only the video module will be rebooted.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_CAMERA_NOT_DETECTED" if no camera was detected.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
    <p>
    \note This method only works for ZED 2, ZED 2i, and newer camera models.
     */
    public static native int sl_reboot(int sn, @Cast("bool") boolean full_reboot);

    /**
    \brief Creates a file for recording the ZED's output into a .SVO or .AVI video.
    
    An SVO is Stereolabs' own format designed for the ZED. It holds the video feed with timestamps as well as info about the camera used to record it.
    @param camera_id : Id of the camera instance.
    @param filename : Filename of the SVO file.
    @param compression_mode : Compression mode. It can be one for the \ref SL_SVO_COMPRESSION_MODE enum.
    @param bitrate : overrides default bitrate of the SVO file, in KBits/s. Only works if \ref SL_SVO_COMPRESSION_MODE is H264 or H265.
    @param target_fps : Defines the target framerate for the recording module.
    @param transcode : In case of streaming input, if set to false, it will avoid decoding/re-encoding and convert directly streaming input to a SVO file.
               This saves a encoding session and can be especially useful on NVIDIA Geforce cards where the number of encoding session is limited.
    @return An \ref SL_ERROR_CODE that defines if SVO file was successfully created and can be filled with images.
     */
    public static native int sl_enable_recording(int camera_id, @Cast("const char*") BytePointer filename, @Cast("SL_SVO_COMPRESSION_MODE") int compression_mode, @Cast("unsigned int") int bitrate, int target_fps, @Cast("bool") boolean transcode);
    public static native int sl_enable_recording(int camera_id, String filename, @Cast("SL_SVO_COMPRESSION_MODE") int compression_mode, @Cast("unsigned int") int bitrate, int target_fps, @Cast("bool") boolean transcode);

    /**
    \brief Get the recording information.
    @return The recording state structure. For more details, see \ref SL_RecordingStatus.
     */
    public static native SL_RecordingStatus sl_get_recording_status(int camera_id);
    /**
    \brief Disables the recording initiated by \ref sl_enable_recording() and closes the generated file.
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_disable_recording(int camera_id);

    /**
    \brief Returns the \ref SL_RecordingParameters used.
    
    It corresponds to the structure given as argument to the \ref sl_enable_recording() function.
    @param camera_id : Id of the camera instance.
    @return \ref SL_RecordingParameters containing the parameters used for recording initialization.
     */
    public static native SL_RecordingParameters sl_get_recording_parameters(int camera_id);

    /**
    \brief Pauses or resumes the recording.
    @param camera_id : Id of the camera instance.
    @param status : If true, the recording is paused. If false, the recording is resumed.
     */
    public static native void sl_pause_recording(int camera_id, @Cast("bool") boolean status);

    /**
    \brief Ingests SL_SVOData in a SVO file.
    @param camera_id : Id of the camera instance.
    @param data : Data to ingest in the SVO file.
    @return sl_ERROR_CODE_SUCCESS in case of success, sl_ERROR_CODE_FAILURE otherwise.
    <p>
    \note The method works only if the camera is recording.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_ingest_data_into_svo(int camera_id, SL_SVOData data);

    /**
    \brief Gets the size of data available for a given key.
    Must be called before sl_retrieve_svo_data to initialize the array at the correct size.
    @param camera_id : Id of the camera instance.
    @param key : The key of the SVOData that is going to be retrieved.
    @param ts_begin : The beginning of the range.
    @param ts_end : The end of the range.
    @return The number of data available for this key.
    <p>
    \note The method will always return -1 if not in SVO mode.
     */
    public static native int sl_get_svo_data_size(int camera_id, @Cast("char*") BytePointer key, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);
    public static native int sl_get_svo_data_size(int camera_id, @Cast("char*") ByteBuffer key, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);
    public static native int sl_get_svo_data_size(int camera_id, @Cast("char*") byte[] key, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);

    /**
    \brief Retrieves SVOData from an SVO file.
    The user is reponsible for correctly allocating the size of the data array using sl_get_svo_data_size.
    @param camera_id : Id of the camera instance.
    @param nb_data : Size of the array of data.
    @param data : The map to be filled with SVOData objects, with timestamps as keys.
    @param ts_begin : The beginning of the range.
    @param ts_end : The end of the range.
    @return sl_ERROR_CODE_SUCCESS in case of success, sl_ERROR_CODE_FAILURE otherwise.
    \note The method will return sl_ERROR_CODE_FAILURE if not in SVO mode.
    \warning You need to call sl_get_svo_data_size for the key before calling this method to correctly retrieve the data.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_retrieve_svo_data(int camera_id, @Cast("char*") BytePointer key, int nb_data, SL_SVOData data, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);
    public static native @Cast("SL_ERROR_CODE") int sl_retrieve_svo_data(int camera_id, @Cast("char*") ByteBuffer key, int nb_data, SL_SVOData data, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);
    public static native @Cast("SL_ERROR_CODE") int sl_retrieve_svo_data(int camera_id, @Cast("char*") byte[] key, int nb_data, SL_SVOData data, @Cast("unsigned long long") long ts_begin, @Cast("unsigned long long") long ts_end);

    /**
    \brief Gets the number of external channels that can be retrieved from the SVO file.
    @param camera_id : Id of the camera instance.
    @return the number of keys available.
    \note The method will return 0 if not in SVO mode.
     */
    public static native int sl_get_svo_data_keys_size(int camera_id);

    /**
    \brief Gets the external channels that can be retrieved from the SVO file.
    The user is reponsible for correctly allocating the size of the keys array using sl_get_svo_data_keys_size.
    @param camera_id : Id of the camera instance.
    @param nb_keys : number of keys.
    @param [Out] keys : List of available keys.
    <p>
    \note The method will not fill the keys array if not in SVO mode.
     */
    public static native void sl_get_svo_data_keys(int camera_id, int nb_keys, @Cast("char**") PointerPointer keys);
    public static native void sl_get_svo_data_keys(int camera_id, int nb_keys, @Cast("char**") @ByPtrPtr BytePointer keys);
    public static native void sl_get_svo_data_keys(int camera_id, int nb_keys, @Cast("char**") @ByPtrPtr ByteBuffer keys);
    public static native void sl_get_svo_data_keys(int camera_id, int nb_keys, @Cast("char**") @ByPtrPtr byte[] keys);

    /**
    \brief Initializes and starts the positional tracking processes.
    <p>
    This function allows you to enable the position estimation of the SDK.
    It only has to be called once in the camera's lifetime.
    <p>
    @param camera_id : Id of the camera instance.
    @param tracking_param : A structure containing all the specific parameters for the positional tracking. Default: a preset of \ref SL_PositionalTrackingParameters.
    @param area_file_path : .area localization file that describes the surroundings, saved from a previous tracking session.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_enable_positional_tracking(int camera_id, SL_PositionalTrackingParameters tracking_param, @Cast("const char*") BytePointer area_file_path);
    public static native int sl_enable_positional_tracking(int camera_id, SL_PositionalTrackingParameters tracking_param, String area_file_path);

    // /**
    // \brief Initializes and starts the positional tracking processes.
    // This function allows you to enable the position estimation of the SDK. It only has to be called once in the camera's lifetime.
    // 
    // \param camera_id : id of the camera instance.
    // \param initial_world_rotation : rotation of the camera in the world frame when the camera is started. By default, it should be identity.
    // \param initial_world_position : position of the camera in the world frame when the camera is started. By default, it should be identity.
    // \param enable_area_memory : this mode enables the camera to remember its surroundings. This helps correct positional tracking drift, and can be helpful for positioning different cameras relative to one other in space.
    // \param enable_pose_smoothing : this mode enables smooth pose correction for small drift correction.
    // \param set_floor_as_origin : this mode initializes the tracking to be aligned with the floor plane to better position the camera in space.
    // \param set_as_static : this mode defines the camera as static. If true, it will not move in the environment. This allows you to set its position using initial_world_transform.
    // \param enable_imu_fusion : this mode enables or disables IMU fusion. When set to false, only the optical odometry will be used.
    // \param area_file_path : area localization file that describes the surroundings, saved from a previous tracking session.
    // \return \ref SL_ERROR_CODE::SUCCESS if everything went fine, ERROR_CODE::FAILURE otherwise.
    //  */
    //  /**INTERFACE_API int enable_positional_tracking(int camera_id, struct SL_Quaternion *initial_world_rotation, struct SL_Vector3 *initial_world_position, bool enable_area_memory, bool enable_pose_smoothing, bool set_floor_as_origin, bool set_as_static,
    //          bool enable_imu_fusion, const char* area_file_path);*/
    
    /**
    \brief Disables the positional tracking.
    @param camera_id : Id of the camera instance.
    @param area_file_path : If set, saves the spatial memory into an '.area' file.
    */
    public static native void sl_disable_positional_tracking(int camera_id, @Cast("const char*") BytePointer area_file_path);
    public static native void sl_disable_positional_tracking(int camera_id, String area_file_path);

    /**
    \brief Saves the current area learning file. The file will contain spatial memory data generated by the tracking.
    @param camera_id : Id of the camera instance.
    @param area_file_path : Save the spatial memory database in an '.area' file.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" if the <b>area_file_path</b> file wasn't found, \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" otherwise.
     */
    public static native int sl_save_area_map(int camera_id, @Cast("const char*") BytePointer area_file_path);
    public static native int sl_save_area_map(int camera_id, String area_file_path);

    /**
    \brief Returns the state of the spatial memory export process.
    <p>
    As \ref sl_save_area_map only starts the exportation, this method allows you to know when the exportation finished or if it failed.
    @param camera_id : Id of the camera instance.
    @return The current \ref SL_AREA_EXPORTING_STATE "state" of the spatial memory export process
     */
    public static native int sl_get_area_export_state(int camera_id);

    /**
    \brief Sets the playback cursor to the desired frame number in the SVO file.
    <p>
    This function allows you to move around within a played-back SVO file. After calling, the next call to sl_grab() will read the provided frame number.
    <p>
    @param camera_id : Id of the camera instance.
    @param frame_number : The number of the desired frame to be decoded.
     */
    public static native void sl_set_svo_position(int camera_id, int frame_number);

    /**
    \brief Returns the camera FPS.
    @param camera_id : Id of the camera instance.
    @return The current frame rate.
     */
    public static native float sl_get_camera_fps(int camera_id);

    /**
    \brief Returns the current FPS.
    @param camera_id : Id of the camera instance.
    @return The current frame rate.
        */
    public static native float sl_get_current_fps(int camera_id);

    /**
    \brief Returns the width of the current image.
    @param camera_id : Id of the camera instance.
    @return Width of the image.
     */
    public static native int sl_get_width(int camera_id);

    /**
    \brief Returns the height of the current image.
    @param camera_id : Id of the camera instance.
    @return Height of the image.
     */
    public static native int sl_get_height(int camera_id);

    /**
    \brief Gets the current confidence threshold value for the disparity map (and by extension the depth map).
    @param camera_id : id of the camera instance.
    @return The confidence threshold. -1 if failure.
     */
    public static native int sl_get_confidence_threshold(int camera_id);

    /**
    \brief Returns the SL_CameraInformation associated the camera.
    <p>
    To ensure accurate calibration, it is possible to specify a custom resolution as a parameter when obtaining scaled information, as calibration parameters are resolution-dependent.
    @param camera_id : Id of the camera instance.
    @param res_width : You can specify a size different from default image size to get the scaled camera information.
    @param res_height : You can specify a size different from default image size to get the scaled camera information.
    @return SL_CameraInformation containing the calibration parameters of the ZED, as well as serial number and firmware version.
     */
    public static native SL_CameraInformation sl_get_camera_information(int camera_id, int res_width, int res_height);

    /**
    \brief Performs a new self calibration process.
    <p>
    In some cases, due to temperature changes or strong vibrations, the stereo calibration becomes less accurate. Use this function to update the self-calibration data and get more reliable depth values.
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_update_self_calibration(int camera_id);

    /**
    \brief Gets the Calibration Parameters.
    @param camera_id : id of the camera instance.
    @param r_params : if true, returns Intrinsic and Extrinsic stereo parameters for original images (unrectified/distorded), else returns parameters for rectified/undistorded images.
    @return Structure containing Intrinsic and Extrinsic stereo parameters
     */
    public static native SL_CalibrationParameters sl_get_calibration_parameters(int camera_id, @Cast("bool") boolean raw_params);

    /**
    \brief Gets the Sensors configuration.
    @param camera_id : id of the camera instance.
    @return Structure containing information about all the sensors available in the current device.
     */
    public static native SL_SensorsConfiguration sl_get_sensors_configuration(int camera_id);

    /**
    \brief Gets the IMU to the left camera transform matrix.
    \note This function is only effective if the camera has a model other than a \ref SL_MODEL "SL_MODEL_ZED", which does not contains internal sensors.
    @param camera_id : Id of the camera instance.
    @param translation : Translation between IMU frame and camera frame.
    @param rotation : Rotation between IMU frame and camera frame.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if sensors data have been extracted.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SENSORS_NOT_AVAILABLE" if the camera model is a \ref SL_MODEL "SL_MODEL_ZED".
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct but the sensors module is not opened.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS" if the <b>reference_time</b> is not valid.
     */
    public static native void sl_get_camera_imu_transform(int camera_id, SL_Vector3 translation, SL_Quaternion rotation);

    /**
    \brief Gets the input type (see \ref SL_INPUT_TYPE).
    @param camera_id : id of the camera instance.
    @return The input type.
     */
    public static native int sl_get_input_type(int camera_id);

    /**
    \brief Gets the ZED Serial Number.
    @param camera_id : id of the camera instance.
    @return The serial number of the camera.
     */
    public static native int sl_get_zed_serial(int camera_id);

    /**
    \brief Gets the ZED camera current firmware version.
    @param camera_id : Id of the camera instance.
    @return The firmware of the camera.
     */
    public static native int sl_get_camera_firmware(int camera_id);

    /**
    \brief Gets the sensor module current firmware version.
    @param camera_id : Id of the camera instance.
    @return The firmware version of the sensor module, 0 if no sensors are available.
     */
    public static native int sl_get_sensors_firmware(int camera_id);

    /**
    \brief Gets the ZED Camera model (see \ref SL_MODEL).
    @param camera_id : id of the camera instance.
    @return The ZED Camera model.
     */
    public static native int sl_get_camera_model(int camera_id);

    /**
    \brief Get the timestamp at the time the frame has been extracted from USB stream.
    
    \note It should be called after a sl_grab().
    @param camera_id : Id of the camera instance.
    @return The camera timestamp.
     */
    public static native @Cast("unsigned long long") long sl_get_image_timestamp(int camera_id);

    /**
    \brief Get the current timestamp at the time the function is called.
    
    Can be compared to the camera timestamp for synchronization.
    @param camera_id : Id of the camera instance.
    @return The current timestamp.
     */
    public static native @Cast("unsigned long long") long sl_get_current_timestamp(int camera_id);

    /**
    \brief Returns the number of frames in the SVO file.
    @param camera_id : Id of the camera instance.
    @return The total number of frames in the SVO file. -1 if the SDK is not reading a SVO.
     */
    public static native int sl_get_svo_number_of_frames(int camera_id);

    /**
    \brief Test if the video setting is supported by the camera
    @param camera_id : Id of the camera instance.
    @param setting : The video setting to test
    @return true if the \ref SL_VIDEO_SETTINGS is supported by the camera, false otherwise
     */
    public static native @Cast("bool") boolean sl_is_camera_setting_supported(int camera_id, @Cast("SL_VIDEO_SETTINGS") int setting);

    /**
    \brief Sets the value of the requested \ref SL_VIDEO_SETTINGS "camera setting" (gain, brightness, hue, exposure, etc.).
    @param camera_id : Id of the camera instance.
    @param mode : The setting to be set.
    @param value : The value to set.
    @return \ref SL_ERROR_CODE to indicate if the function was successful.
    \note The function works only if the camera is open in LIVE or STREAM mode.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_set_camera_settings(int camera_id, @Cast("SL_VIDEO_SETTINGS") int mode, int value);

    /**
    \brief Sets the range values of the requested \ref SL_VIDEO_SETTINGS "camera setting" (gain, brightness, hue, exposure, etc.).
    Works for the following settings: 
    \ref SL_VIDEO_SETTINGS SL_VIDEO_SETTINGS_AUTO_EXPOSURE_TIME_RANGE
    \ref SL_VIDEO_SETTINGS SL_VIDEO_SETTINGS_AUTO_ANALOG_GAIN_RANGE
    \ref SL_VIDEO_SETTINGS SL_VIDEO_SETTINGS_AUTO_DIGITAL_GAIN_RANGE
    
    @param camera_id : Id of the camera instance.
    @param mode : The setting to be set.
    @param min : The min value to set.
    @param max : The max value to set.
    @return \ref SL_ERROR_CODE to indicate if the function was successful.
    \note The function works only if the camera is open in LIVE or STREAM mode.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_set_camera_settings_min_max(int camera_id, @Cast("SL_VIDEO_SETTINGS") int mode, int min, int max);

    /**
    \brief Sets the region of interest for automatic exposure/gain computation
    @param camera_id : Id of the camera instance.
    @param side : \ref SL_SIDE on which to be applied for AEC/AGC computation.
    @param roi : \ref SL_Rect that defines the target to be applied for AEC/AGC computation. Must be given according to camera resolution.
    @param reset : Cancel the manual ROI and reset it to the full image.
    @return \ref SL_ERROR_CODE to indicate if the function was successful.
    \note The function works only if the camera is open in LIVE or STREAM mode.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_set_roi_for_aec_agc(int camera_id, @Cast("SL_SIDE") int side, SL_Rect roi, @Cast("bool") boolean reset);

    /**
    \brief Returns the current value of the requested \ref SL_VIDEO_SETTINGS "camera setting" (gain, brightness, hue, exposure, etc.).
    @param camera_id : Id of the camera instance.
    @param mode : Setting to be retrieved (see \ref SL_VIDEO_SETTINGS).
    @param value : The requested setting value.
    @return \ref SL_ERROR_CODE to indicate if the function was successful. If successful, setting will be filled with the corresponding value.
    \note The function works only if the camera is open in LIVE or STREAM mode.
    \note Settings are not exported in the SVO file format.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, IntPointer value);
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, IntBuffer value);
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, int[] value);

    /**
    \brief Returns the current range of the requested \ref SL_VIDEO_SETTINGS "camera setting" (setting with range value).
    @param camera_id : Id of the camera instance.
    @param mode : Setting to be retrieved (see \ref SL_VIDEO_SETTINGS).
    @param value : The requested setting value.
    @return \ref SL_ERROR_CODE to indicate if the function was successful. If successful, setting will be filled with the corresponding value.
    \note The function works only if the camera is open in LIVE or STREAM mode.
    \note Settings are not exported in the SVO file format.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings_min_max(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, IntPointer minvalue, IntPointer maxvalue);
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings_min_max(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, IntBuffer minvalue, IntBuffer maxvalue);
    public static native @Cast("SL_ERROR_CODE") int sl_get_camera_settings_min_max(int c_id, @Cast("SL_VIDEO_SETTINGS") int mode, int[] minvalue, int[] maxvalue);

    /**
    \brief Gets the region of interest for automatic exposure/gain computation.
    @param camera_id : Id of the camera instance.
    @param side : \ref SL_SIDE on which to get the ROI from.
    @param roi [Out] : Region of interest.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if ROI has been applied. Other \ref SL_ERROR_CODE otherwise.
    \note The function works only if the camera is open in LIVE or STREAM mode.
    \note Settings are not exported in the SVO file format.
     */
    public static native @Cast("SL_ERROR_CODE") int sl_get_roi_for_aec_agc(int id, @Cast("SL_SIDE") int side, SL_Rect roi);

    /**
    \brief Gets the depth min value from InitParameters (see \ref SL_InitParameters::depth_minimum_distance).
    @param camera_id : id of the camera instance.
    @return The min depth value available. -1 if failure.
     */
    public static native float sl_get_depth_min_range_value(int camera_id);

    /**
    \brief Gets the depth max value from InitParameters (see \ref SL_InitParameters::depth_maximum_distance).
    @param camera_id : id of the camera instance.
    @return The max depth value available. -1 if failure.
     */
    public static native float sl_get_depth_max_range_value(int camera_id);

    /**
    \brief Gets the current range of perceived depth.
    @param camera_id : Id of the camera instance.
    @param min : [Out] Minimum depth detected (in selected \ref SL_UNIT)
    @param max : [Out] Maximum depth detected (in selected \ref SL_UNIT).
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if values have been extracted. Other \ref SL_ERROR_CODE otherwise.
     */
    public static native int sl_get_current_min_max_depth(int camera_id, FloatPointer min, FloatPointer max);
    public static native int sl_get_current_min_max_depth(int camera_id, FloatBuffer min, FloatBuffer max);
    public static native int sl_get_current_min_max_depth(int camera_id, float[] min, float[] max);

    /**
    \brief Gets the number of zed connected.
    @return The number of Zed cameras connected.
     */
    public static native int sl_get_number_zed_connected();

    /**
    \brief Returns the version of the currently installed ZED SDK.
    @return The ZED SDK version installed.
     */
    public static native @Cast("char*") BytePointer sl_get_sdk_version();

    /**
    \brief Change the coordinate system of a transform matrix.
    @param rotation [In, Out] : rotation to transform.
    @param translation [In, Out] : translation to transform.
    @param coord_system_src : the current coordinate system of the translation/rotation.
    @param coord_system_dest: the destination coordinate system for the translation/rotation.
     */
    public static native int sl_convert_coordinate_system(SL_Quaternion rotation, SL_Vector3 translation, @Cast("SL_COORDINATE_SYSTEM") int coord_system_src, @Cast("SL_COORDINATE_SYSTEM") int coord_system_dest);

    // /**
    // \brief Returns the version of the currently installed ZED SDK.
    // \param major : major int of the version filled
    // \param minor : minor int of the version filled
    // \param patch : patch int of the version filled
    //  */
    // INTERFACE_API void sl_get_sdk_version(int *major, int *minor, int *patch);

     /**
     \brief Returns the current playback position in the SVO file.
     @param camera_id : Id of the camera instance.
     @return The current frame position in the SVO file. Returns -1 if the SDK is not reading an SVO.
      */
    public static native int sl_get_svo_position(int camera_id);

    /**
    * \brief Retrieves the frame index within the SVO file corresponding to the provided timestamp.
    *  @param camera_id : Id of the camera instance.
    * @param timestamp The target timestamp for which the frame index is to be determined.
    * @return The frame index within the SVO file that aligns with the given timestamp.
    *         Returns -1 if the timestamp falls outside the bounds of the SVO file.
    */
    public static native int sl_get_svo_position_at_timestamp(int camera_id, @Cast("unsigned long long") long timestamp);

    /**
    \brief Gets the number of frames dropped since sl_grab() was called for the first time. Based on camera timestamps and an FPS comparison.
    @param camera_id : Id of the camera instance.
    @return The number of frames dropped since the first sl_grab() call.
     */
    public static native @Cast("unsigned int") int sl_get_frame_dropped_count(int camera_id);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Motion tracking ///////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Tells if the tracking module is enabled.
    @param camera_id : Id of the camera instance.
    */
    public static native @Cast("bool") boolean sl_is_positional_tracking_enabled(int camera_id);

    /**
    \brief Gets the current position of the camera and state of the tracking, with an optional offset to the tracking frame.
    @param camera_id : Id of the camera instance.
    @param rotation : Quaternion filled with the current rotation of the camera depending on its reference frame.
    @param position : Vector filled with the current position of the camera depending on its reference frame.
    @param target_quaternion : Rotational offset applied to the tracking frame.
    @param target_translation : Positional offset applied to the tracking frame.
    @param reference_frame : Reference frame for setting the rotation/position.
    @return The current state of the tracking process (see \ref SL_POSITIONAL_TRACKING_STATE).
     */
    public static native int sl_get_position_at_target_frame(int camera_id, SL_Quaternion rotation, SL_Vector3 _position, SL_Quaternion target_quaternion, SL_Vector3 target_translation, @Cast("SL_REFERENCE_FRAME") int reference_frame);
    /**
    \brief Gets the current position of the camera and state of the tracking, filling a \ref SL_PoseData struck useful for AR pass-though.
    @param camera_id : Id of the camera instance.
    @param poseData : Current Pose.
    @param reference_frame : Reference frame sor setting the rotation/position.
    @return The current state of the tracking process (see \ref SL_POSITIONAL_TRACKING_STATE).
     */
    public static native int sl_get_position_data(int camera_id, SL_PoseData poseData, @Cast("SL_REFERENCE_FRAME") int reference_frame);
    /**
    \brief Retrieves the estimated position and orientation of the camera in the specified \ref REFERENCE_FRAME "reference frame".
    @param camera_id : Id of the camera instance.
    @param rotation : Quaternion filled with the current rotation of the camera depending on its reference frame.
    @param position : Vector filled with the current position of the camera depending on its reference frame.
    @param reference_frame : Reference frame for setting the rotation/position.
    @return The current state of the tracking process (see \ref SL_POSITIONAL_TRACKING_STATE).
     */
    public static native int sl_get_position(int camera_id, SL_Quaternion rotation, SL_Vector3 _position, @Cast("SL_REFERENCE_FRAME") int reference_frame);
    /**
    \brief Gets the position of the camera and the current state of the ZED Tracking as a float array (4x4).
    @param camera_id : id of the camera instance.
    @param pose : pose of the camera as a float array (float[16]).
    @param reference_frame : the reference from which you want the pose to be expressed (see SL_REFERENCE_FRAME::WORLD).
    @return The Positional tracking state.
     */
    public static native int sl_get_position_array(int camera_id, FloatPointer pose, @Cast("SL_REFERENCE_FRAME") int reference_frame);
    public static native int sl_get_position_array(int camera_id, FloatBuffer pose, @Cast("SL_REFERENCE_FRAME") int reference_frame);
    public static native int sl_get_position_array(int camera_id, float[] pose, @Cast("SL_REFERENCE_FRAME") int reference_frame);

    /**
     \brief Return the current status of positional tracking module.
     @return SL_POSITIONAL_TRACKING_STATUS current status of positional tracking module.
     */
    public static native SL_PositionalTrackingStatus sl_get_positional_tracking_status(int camera_id);

    /**
    \brief Resets the tracking, and re-initializes the position with the given pose.
    @param camera_id : Id of the camera instance.
    @param rotation : Rotation of the camera in the world frame when the function is called.
    @param translation : Position of the camera in the world frame when the function is called.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the tracking has been reset, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_reset_positional_tracking(int camera_id, @ByVal SL_Quaternion rotation, @ByVal SL_Vector3 translation);
    /**
    \brief Resets the tracking with an offset.
    @param camera_id : Id of the camera instance.
    @param rotation : Rotation of the camera in the world frame when the function is called.
    @param translation : Position of the camera in the world frame when the function is called.
    @param target_quaternion : Rotation offset to apply.
    @param target_translation : Translation offset to apply.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the tracking has been reset, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_reset_positional_tracking_with_offset(int camera_id, @ByVal SL_Quaternion rotation, @ByVal SL_Vector3 translation, @ByVal SL_Quaternion target_quaternion, @ByVal SL_Vector3 target_translation);
    /**
    \brief Set an optional IMU orientation hint that will be used to assist the tracking during the next \ref sl_grab().
    
    Prior must come from a external IMU, such as the HMD orientation and should be in a time frame that's as close as possible to the camera.
    \note This function is only effective if the camera has a model other than a \ref SL_MODEL "SL_MODEL_ZED", which does not contains internal sensors.
    
    @param rotation : Prior rotation.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if sensors data have been extracted.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SENSORS_NOT_AVAILABLE" if the camera model is a \ref SL_MODEL "SL_MODEL_ZED".
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct but the sensors module is not opened.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS" if the <b>reference_time</b> is not valid.
     */
    public static native int sl_set_imu_prior_orientation(int camera_id, @ByVal SL_Quaternion rotation);
    /**
    \brief Gets the rotation given by the IMU.
    \note This function is only effective if the camera has a model other than a \ref SL_MODEL "SL_MODEL_ZED", which does not contains internal sensors.
    @param camera_id : id of the camera instance.
    @param quat : [Out] Rotation from the IMU.
    @param time_reference : time reference.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if sensors data have been extracted.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SENSORS_NOT_AVAILABLE" if the camera model is a \ref SL_MODEL "SL_MODEL_ZED".
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct but the sensors module is not opened.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS" if the <b>reference_time</b> is not valid.
     */
    public static native int sl_get_imu_orientation(int camera_id, SL_Quaternion quat, @Cast("SL_TIME_REFERENCE") int time_reference);
    /**
    \brief Gets \ref SL_SensorsData (IMU, magnetometer, barometer) at a specific time reference.
    \note This function is only effective if the camera has a model other than a \ref SL_MODEL "SL_MODEL_ZED", which does not contains internal sensors.
    @param camera_id : Id of the camera instance.
    @param data : The \ref SL_SensorsData variable to store the data.
    @param time_reference : Defines the reference from which you want the data to be expressed.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if sensors data have been extracted.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SENSORS_NOT_AVAILABLE" if the camera model is a \ref SL_MODEL "SL_MODEL_ZED".
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct but the sensors module is not opened.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS" if the <b>reference_time</b> is not valid.
     */
    public static native int sl_get_sensors_data(int camera_id, SL_SensorsData data, @Cast("SL_TIME_REFERENCE") int time_reference);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Spatial Mapping ///////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Consolidates the chucks from a scan. This is used to turn a lots of small meshes (which are efficient for the scanning process)
    into several large meshes (which are more convenient to work with).
    @param camera_id : id of the camera instance.
    @param nb_faces : define the new number of faces per chunk (useful for Unity that doesn't handle chunks over 65K vertices).
    @param nb_vertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_updated_submeshes : Number of sub-meshes.
    @param updates_indices : List of all sub-meshes updated since the last update.
    @param nb_vertices_tot : Total number of updated vertices in all sub-meshes.
    @param nb_triangles_tot : Total number of updated triangles in all sub-meshes.
    @param max_sub_mesh : Maximum number of sub-meshes.
     */
    public static native void sl_spatial_mapping_merge_chunks(int camera_id, int nb_faces, IntPointer nb_vertices, IntPointer nb_triangles, IntPointer nb_updated_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, int max_submesh);
    public static native void sl_spatial_mapping_merge_chunks(int camera_id, int nb_faces, IntBuffer nb_vertices, IntBuffer nb_triangles, IntBuffer nb_updated_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, int max_submesh);
    public static native void sl_spatial_mapping_merge_chunks(int camera_id, int nb_faces, int[] nb_vertices, int[] nb_triangles, int[] nb_updated_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int max_submesh);

    /**
    \brief Initializes and starts the spatial mapping processes.
    @param camera_id : Id of the camera instance.
    @param type : Spatial mapping type (see \ref SL_SPATIAL_MAP_TYPE).
    @param resolution_meter : Spatial mapping resolution in meters.
    @param max_range_meter : Maximum scanning range in meters.
    @param save_texture : True to scan surface textures in addition to geometry.
    @param max_memory_usage : The maximum CPU memory (in megabytes) allocated for the meshing process.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_enable_spatial_mapping(int camera_id, SL_SpatialMappingParameters mapping_param);
    /**
    \brief Disables the spatial mapping process.
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_disable_spatial_mapping(int camera_id);

    /**
    \brief Returns the SL_SpatialMappingParameters used.
    <p>
    It corresponds to the structure given as argument to the \ref sl_enable_spatial_mapping() method.
    @param camera_id : Id of the camera instance.
    @return \ref SL_SpatialMappingParameters containing the parameters used for spatial mapping initialization.
     */
    public static native SL_SpatialMappingParameters sl_get_spatial_mapping_parameters(int camera_id);
    /**
     Pauses or resumes the spatial mapping processes.
     @param camera_id : Id of the camera instance.
     @param status : If true, the integration is paused. If false, the spatial mapping is resumed.
     */
    public static native void sl_pause_spatial_mapping(int camera_id, @Cast("bool") boolean status);
    /**
    \brief Starts the spatial map generation process in a non-blocking thread from the spatial mapping process.
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_request_mesh_async(int camera_id);
    /**
    \brief Returns the spatial map generation status.
    
    Useful for knowing when to update and retrieve the mesh or the point cloud.
    @param camera_id : Id of the camera instance.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the mesh or the point cloud is ready and not yet retrieved, otherwise \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE".
     */
    public static native int sl_get_mesh_request_status_async(int camera_id);
    /**
    \brief Returns the current spatial mapping state.
    <p>
    As the spatial mapping runs asynchronously, this function allows you to get reported errors or status info.
    @param camera_id : Id of the camera instance.
    @return The current \ref SL_SPATIAL_MAPPING_STATE "state" of the spatial mapping process.
     */
    public static native @Cast("SL_SPATIAL_MAPPING_STATE") int sl_get_spatial_mapping_state(int camera_id);
    /**
    \brief Updates the internal version of the mesh and returns the sizes of the meshes.
    @param camera_id : Id of the camera instance.
    @param nb_vertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_submeshes : Number of sub-meshes.
    @param updates_indices : List of all sub-meshes updated since the last update.
    @param num_vertices_tot : Total number of updated vertices in all sub-meshes.
    @param num_triangles_tot : Total number of updated triangles in all sub-meshes.
    @param max_sub_mesh : Maximum number of sub-meshes.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the mesh is updated.
     */
    public static native int sl_update_mesh(int camera_id, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer nb_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, int max_submesh);
    public static native int sl_update_mesh(int camera_id, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer nb_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, int max_submesh);
    public static native int sl_update_mesh(int camera_id, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] nb_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int max_submesh);
    /**
    \brief Retrieves all chunks of the current mesh.
    \note Call \ref sl_update_mesh before calling this.
    
    Vertex and triangles arrays must be at least of the sizes returned by \ref sl_update_mesh (nb_vertices and nb_triangles).
    @param camera_id : Id of the camera instance.
    @param vertices : Vertices of the mesh
    @param triangles : Triangles of the mesh.
    @param colors : BGR colors of each vertex.
    @param max_submeshes : Maximum number of sub-mesh that can be handled.
    @param uvs : UVs of the texture.
    @param texture_ptr : Texture of the mesh (if enabled).
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the mesh is retrieved.
     */
    public static native int sl_retrieve_mesh(int camera_id, FloatPointer vertices, IntPointer triangles, @Cast("unsigned char*") BytePointer colors, FloatPointer uvs, @Cast("unsigned char*") BytePointer texture_ptr, int max_submeshes);
    public static native int sl_retrieve_mesh(int camera_id, FloatBuffer vertices, IntBuffer triangles, @Cast("unsigned char*") ByteBuffer colors, FloatBuffer uvs, @Cast("unsigned char*") ByteBuffer texture_ptr, int max_submeshes);
    public static native int sl_retrieve_mesh(int camera_id, float[] vertices, int[] triangles, @Cast("unsigned char*") byte[] colors, float[] uvs, @Cast("unsigned char*") byte[] texture_ptr, int max_submeshes);
    /**
    \brief Updates the Internal version of the mesh and returns the sizes of the meshes.
    @param camera_id : Id of the camera instance.
    @param nb_vertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_submeshes : Number of sub-meshes.
    @param updates_indices : List of all sub-meshes updated since the last update.
    @param num_vertices_tot : Total number of updated vertices in all sub-meshes.
    @param num_triangles_tot : Total number of updated triangles in all sub-meshes.
    @param max_sub_mesh : Maximum number of sub-meshes.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the chunks are updated.
     */
    public static native int sl_update_chunks(int camera_id, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer nb_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, int max_submesh);
    public static native int sl_update_chunks(int camera_id, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer nb_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, int max_submesh);
    public static native int sl_update_chunks(int camera_id, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] nb_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int max_submesh);
    /**
    \brief Retrieves all chunks of the full mesh.
    \note Call \ref sl_update_mesh before calling this.
    
    Vertex and triangles arrays must be at least of the sizes returned by \ref sl_update_mesh (nbVertices and nbTriangles).
    @param camera_id : Id of the camera instance.
    @param max_submesh : Maximum number of sub-mesh that can be handled.
    @param vertices : Vertices of the chunk.
    @param triangles : Triangles of the chunk.
    @param colors : BGR colors of the chunk.
    @param uvs : UVs of the texture.
    @param texture_ptr : Texture of the mesh (if enabled).
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the chunk is retrieved.
     */
    public static native int sl_retrieve_chunks(int camera_id, FloatPointer vertices, IntPointer triangles, @Cast("unsigned char*") BytePointer colors, FloatPointer uvs, @Cast("unsigned char*") BytePointer texture_ptr, int max_submesh);
    public static native int sl_retrieve_chunks(int camera_id, FloatBuffer vertices, IntBuffer triangles, @Cast("unsigned char*") ByteBuffer colors, FloatBuffer uvs, @Cast("unsigned char*") ByteBuffer texture_ptr, int max_submesh);
    public static native int sl_retrieve_chunks(int camera_id, float[] vertices, int[] triangles, @Cast("unsigned char*") byte[] colors, float[] uvs, @Cast("unsigned char*") byte[] texture_ptr, int max_submesh);

    /**
    \brief Updates the fused point cloud (if spatial map type was \ref SL_SPATIAL_MAP_TYPE "SL_SPATIAL_MAP_TYPE_FUSED_POINT_CLOUD").
    @param camera_id : Id of the camera instance.
    @param num_vertices_tot : The total number of vertices.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the fused point cloud is updated.
     */
    public static native int sl_update_fused_point_cloud(int camera_id, IntPointer nb_vertices_tot);
    public static native int sl_update_fused_point_cloud(int camera_id, IntBuffer nb_vertices_tot);
    public static native int sl_update_fused_point_cloud(int camera_id, int[] nb_vertices_tot);
    /**
    \brief Retrieves all points of the fused point cloud.
    \note Call \ref sl_update_fused_point_cloud before calling this.
    @param camera_id : Id of the camera instance.
    @param vertices : Points of the fused point cloud.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the fused point cloud is retrieved.
     */
    public static native int sl_retrieve_fused_point_cloud(int camera_id, FloatPointer vertices);
    public static native int sl_retrieve_fused_point_cloud(int camera_id, FloatBuffer vertices);
    public static native int sl_retrieve_fused_point_cloud(int camera_id, float[] vertices);
    /**
    \brief Extracts the current spatial map from the spatial mapping process.
    @param camera_id : Id of the camera instance.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the mesh is filled and available, otherwise \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE".
     */
    public static native int sl_extract_whole_spatial_map(int camera_id);
    /**
    \brief Saves the scanned mesh in a specific file format.
    @param camera_id : Id of the camera instance.
    @param filename : Path and filename of the mesh.
    @param format : File format (extension). Can be .obj, .ply or .bin.
    @return Has the mesh been save successfully.
     */
    public static native @Cast("bool") boolean sl_save_mesh(int camera_id, @Cast("const char*") BytePointer filename, @Cast("SL_MESH_FILE_FORMAT") int format);
    public static native @Cast("bool") boolean sl_save_mesh(int camera_id, String filename, @Cast("SL_MESH_FILE_FORMAT") int format);
    /**
    \brief Saves the scanned point cloud in a specific file format.
    @param camera_id : Id of the camera instance.
    @param filename : Path and filename of the point cloud.
    @param format : File format (extension). Can be .obj, .ply or .bin.
    @return Has the point cloud been save successfully.
     */
    public static native @Cast("bool") boolean sl_save_point_cloud(int c_id, @Cast("const char*") BytePointer filename, @Cast("SL_MESH_FILE_FORMAT") int format);
    public static native @Cast("bool") boolean sl_save_point_cloud(int c_id, String filename, @Cast("SL_MESH_FILE_FORMAT") int format);
    /**
    \brief Loads a saved mesh file.
    @param camera_id : Id of the camera instance.
    @param filename : Path and filename of the mesh. Should include the extension (.obj, .ply or .bin).
    @param nb_ertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_sub_meshes : Number of sub-meshes.
    @param updated_indices : List of all sub-meshes updated since the last update.
    @param nb_vertices_tot :  Total number of updated vertices in all sub-meshes.
    @param nb_triangles_tot : Array of the number of triangles in each sub-mesh.
    @param max_submesh : Maximum number of sub-meshes that can be handled.
    @param texture_size : Array containing the sizes of all the textures (width, height) if applicable.
    @return Has the mesh been loaded successfully.
     */
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, @Cast("const char*") BytePointer filename, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer num_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, IntPointer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, String filename, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer num_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, IntBuffer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, @Cast("const char*") BytePointer filename, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] num_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int[] textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, String filename, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer num_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, IntPointer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, @Cast("const char*") BytePointer filename, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer num_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, IntBuffer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_load_mesh(int camera_id, String filename, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] num_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int[] textures_size, int max_submesh);
    /**
    \brief Applies the scanned texture onto the internal scanned mesh.
    @param camera_id : Id of the camera instance.
    @param nb_vertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_sub_meshes : Number of sub-meshes.
    @param updated_indices : List of all sub-meshes updated since the last update.
    @param nb_vertices_tot : Total number of updated vertices in all sub-meshes.
    @param nb_triangles_tot : Array of the number of triangles in each sub-mesh.
    @param max_submesh : Maximum number of sub-meshes that can be handled.
    @param texture_size : Array containing the sizes of all the textures (width, height) if applicable.
    @return Has the texture been applied successfully.
     */
    public static native @Cast("bool") boolean sl_apply_texture(int camera_id, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer nb_updated_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, IntPointer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_apply_texture(int camera_id, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer nb_updated_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, IntBuffer textures_size, int max_submesh);
    public static native @Cast("bool") boolean sl_apply_texture(int camera_id, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] nb_updated_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int[] textures_size, int max_submesh);
    /**
    \brief Filters a mesh to removes triangles while still preserving its overall shaper (though less accurate).
    @param camera_id : Id of the camera instance.
    @param filter_params : Filter level. Higher settings remove more triangles (\ref SL_MESH_FILTER).
    @param nb_vertices : Array of the number of vertices in each sub-mesh.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param nb_sub_meshes : Number of sub-meshes.
    @param updated_indices : List of all sub-meshes updated since the last update.
    @param nb_vertices_tot : Total number of updated vertices in all sub-meshes.
    @param nb_triangles_tot : Array of the number of triangles in each sub-mesh.
    @param max_submesh : Maximum number of sub-meshes that can be handled.
    @return Has the mesh been filtered successfully.
     */
    public static native @Cast("bool") boolean sl_filter_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, IntPointer nb_vertices_per_submesh, IntPointer nb_triangles_per_submesh, IntPointer nb_updated_submeshes, IntPointer updated_indices, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot, int max_submesh);
    public static native @Cast("bool") boolean sl_filter_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, IntBuffer nb_vertices_per_submesh, IntBuffer nb_triangles_per_submesh, IntBuffer nb_updated_submeshes, IntBuffer updated_indices, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot, int max_submesh);
    public static native @Cast("bool") boolean sl_filter_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, int[] nb_vertices_per_submesh, int[] nb_triangles_per_submesh, int[] nb_updated_submeshes, int[] updated_indices, int[] nb_vertices_tot, int[] nb_triangles_tot, int max_submesh);
    /**
    \brief Gets a vector pointing toward the direction of gravity. This is estimated from a 3D scan of the environment,
    and such, a scan must be started and finished for this value to be calculated.
    \n If using a model other than \ref SL_MODEL "SL_MODEL_ZED", this isn't required thanks to its IMU.
    @param camera_id : Id of the camera instance.
    @param gravity : [Out] The vector of gravity.
     */
    public static native void sl_spatial_mapping_get_gravity_estimation(int camera_id, SL_Vector3 gravity);


    //////////////////

     /**
    \brief Updates the internal version of the whole mesh and returns the size of its data.
    @param camera_id : id of the camera instance.
    @param nb_vertices : Total number of updated vertices in all sub-meshes.
    @param nb_triangles : Total number of updated triangles in all sub-meshes.
    @return SUCCESS if the chunks are updated.
     */
    public static native int sl_update_whole_mesh(int camera_id, IntPointer nb_vertices, IntPointer nb_triangles);
    public static native int sl_update_whole_mesh(int camera_id, IntBuffer nb_vertices, IntBuffer nb_triangles);
    public static native int sl_update_whole_mesh(int camera_id, int[] nb_vertices, int[] nb_triangles);
    /**
    \brief Retrieves the full mesh. Call update_mesh before calling this.
    Vertex and triangles arrays must be at least of the sizes returned by update_mesh (nb_vertices and nbTriangles).
    @param camera_id : id of the camera instance.
    @param vertices : Vertices of the mesh
    @param triangles : Triangles of the mesh.
    @param colors : (b,g,r) colors of the mesh.
    @param uvs : uvs of the texture.
    @param texture_ptr : Texture of the mesh (if enabled).
    @return SUCCESS if the chunk is retrieved.
     */
    public static native int sl_retrieve_whole_mesh(int camera_id, FloatPointer vertices, IntPointer triangles, @Cast("unsigned char*") BytePointer colors,  FloatPointer uvs, @Cast("unsigned char*") BytePointer texture_ptr);
    public static native int sl_retrieve_whole_mesh(int camera_id, FloatBuffer vertices, IntBuffer triangles, @Cast("unsigned char*") ByteBuffer colors,  FloatBuffer uvs, @Cast("unsigned char*") ByteBuffer texture_ptr);
    public static native int sl_retrieve_whole_mesh(int camera_id, float[] vertices, int[] triangles, @Cast("unsigned char*") byte[] colors,  float[] uvs, @Cast("unsigned char*") byte[] texture_ptr);
    /**
    \brief Loads a saved mesh file.
    @param camera_id : id of the camera instance.
    @param filename : Path and filename of the mesh. Should include the extension (.obj, .ply or .bin).
    @param nb_vertices :  Total number of updated vertices in all sub-meshes.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param max_submesh : Maximum number of sub-meshes that can be handled.
    @param texture_size : Array containing the sizes of all the textures (width ,height) if applicable.
    @return Has the mesh been loaded successfully.
     */
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, @Cast("const char*") BytePointer filename, IntPointer nb_vertices, IntPointer nb_triangles, IntPointer texture_size);
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, String filename, IntBuffer nb_vertices, IntBuffer nb_triangles, IntBuffer texture_size);
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, @Cast("const char*") BytePointer filename, int[] nb_vertices, int[] nb_triangles, int[] texture_size);
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, String filename, IntPointer nb_vertices, IntPointer nb_triangles, IntPointer texture_size);
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, @Cast("const char*") BytePointer filename, IntBuffer nb_vertices, IntBuffer nb_triangles, IntBuffer texture_size);
    public static native @Cast("bool") boolean sl_load_whole_mesh(int camera_id, String filename, int[] nb_vertices, int[] nb_triangles, int[] texture_size);
    /**
    \brief Applies the scanned texture onto the internal scanned mesh.
    @param camera_id : id of the camera instance.
    @param nb_vertices :  Total number of updated vertices in all sub-meshes.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @param texture_size : Array containing the sizes of all the textures (width ,height) if applicable.
    @return Has the texture been applied successfully.
     */
    public static native @Cast("bool") boolean sl_apply_whole_texture(int camera_id, IntPointer nb_vertices, IntPointer nb_triangles, IntPointer texture_size);
    public static native @Cast("bool") boolean sl_apply_whole_texture(int camera_id, IntBuffer nb_vertices, IntBuffer nb_triangles, IntBuffer texture_size);
    public static native @Cast("bool") boolean sl_apply_whole_texture(int camera_id, int[] nb_vertices, int[] nb_triangles, int[] texture_size);
    /**
    \brief Filters a mesh to removes triangles while still preserving its overall shaper (though less accurate).
    @param camera_id : id of the camera instance.
    @param nb_vertices :  Total number of updated vertices in all sub-meshes.
    @param nb_triangles : Array of the number of triangles in each sub-mesh.
    @return Has the mesh been filtered successfully.
     */
    public static native @Cast("bool") boolean sl_filter_whole_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, IntPointer nb_vertices, IntPointer nb_triangles);
    public static native @Cast("bool") boolean sl_filter_whole_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, IntBuffer nb_vertices, IntBuffer nb_triangles);
    public static native @Cast("bool") boolean sl_filter_whole_mesh(int camera_id, @Cast("SL_MESH_FILTER") int filter_params, int[] nb_vertices, int[] nb_triangles);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Plane Detection ///////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Detect the floor plane of the scene.
    @param camera_id : Id of the camera instance.
    @param reset_quaternion : The rotation to align the axis with the gravity.
    @param reset_translation : The translation to align the tracking with the floor plane. The initial position will then be at ground height.
    @param prior_rotation : Prior rotation.
    @param prior_translation : Prior translation.
    @return The detected floor plane if the function succeeded.
     */
    public static native SL_PlaneData sl_find_floor_plane(int camera_id, SL_Quaternion reset_quaternion, SL_Vector3 reset_translation, @ByVal SL_Quaternion prior_rotation, @ByVal SL_Vector3 prior_translation);
    /**
    \brief Checks the plane at the given left image coordinates.
    @param camera_id : Id of the camera instance.
    @param pixel : The image coordinate. The coordinate must be taken from the full-size image.
    @param params : A structure containing all the specific parameters for the plane detection. Default: a preset of \ref SL_PlaneDetectionParameters.
    @param thres : Check if area is enough for Unity. If true, removes smaller planes.
    @return Data of the detected plane.
     */
    public static native SL_PlaneData sl_find_plane_at_hit(int camera_id, @ByVal SL_Vector2 pixel, SL_PlaneDetectionParameters params, @Cast("bool") boolean thres);
    /**
    \brief Using data from a detected floor plane, updates supplied vertex and triangles arrays with data needed to make a mesh that represents it.
    @param camera_id : id of the camera instance.
    @param vertices : Array to be filled with mesh vertices.
    @param triangles : Array to be filled with mesh triangles, stored as indexes of each triangle's points.
    @param nb_vertices_tot : Total number of vertices in the mesh.
    @param nb_triangles_tot : Total triangles indexes (3x number of triangles).
    @return SUCCESS if the mesh conversion was successful.
     */
    public static native int sl_convert_floorplane_to_mesh(int camera_id, FloatPointer vertices, IntPointer triangles, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot);
    public static native int sl_convert_floorplane_to_mesh(int camera_id, FloatBuffer vertices, IntBuffer triangles, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot);
    public static native int sl_convert_floorplane_to_mesh(int camera_id, float[] vertices, int[] triangles, int[] nb_vertices_tot, int[] nb_triangles_tot);
    /**
    \brief Using data from a detected hit plane, updates supplied vertex and triangles arrays with data needed to make a mesh that represents it.
    @param camera_id : id of the camera instance.
    @param vertices : Array to be filled with mesh vertices.
    @param triangles : Array to be filled with mesh triangles, stored as indexes of each triangle's points.
    @param nb_vertices_tot : Total number of vertices in the mesh.
    @param nb_triangles_tot : Total triangles indexes (3x number of triangles).
    @return SUCCESS if the mesh conversion was successful.
     */
    public static native int sl_convert_hitplane_to_mesh(int camera_id, FloatPointer vertices, IntPointer triangles, IntPointer nb_vertices_tot, IntPointer nb_triangles_tot);
    public static native int sl_convert_hitplane_to_mesh(int camera_id, FloatBuffer vertices, IntBuffer triangles, IntBuffer nb_vertices_tot, IntBuffer nb_triangles_tot);
    public static native int sl_convert_hitplane_to_mesh(int camera_id, float[] vertices, int[] triangles, int[] nb_vertices_tot, int[] nb_triangles_tot);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////// Retrieve /////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Retrieves a measure texture from the ZED SDK.
    
    Use this to get an individual texture from the last grabbed frame with measurements in every pixel - such as depth map, confidence map etc.
    \n Measure textures are not human-viewable but don't lose accuracy, unlike image textures.
    @param camera_id : Id of the camera instance.
    @param measure_ptr : Pointer to the measure texture.
    @param type : Measure type (depth, confidence, xyz, etc). See \ref SL_MEASURE.
    @param mem : Whether the measure should be on CPU or GPU memory. See \ref SL_MEM.
    @param width : Width of the texture in pixel.
    @param height : Height of the texture in pixel.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the retrieve succeeded.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS" if the view mode requires a module not enabled (VIEW::DEPTH with DEPTH_MODE::NONE for example).
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_RESOLUTION" if the resolution is higher than one provided by getCameraInformation().camera_configuration.resolution.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" if another error occurred.
     */
    public static native int sl_retrieve_measure(int camera_id, Pointer measure_ptr, @Cast("SL_MEASURE") int type, @Cast("SL_MEM") int mem, int width, int height);
    /**
    \brief Retrieves an image texture from the ZED SDK in a human-viewable format.
    
    Image textures work for when you want the result to be visible, such as the direct RGB image from the camera, or a greyscale image of the depth.
    However it will lose accuracy if used to show measurements like depth or confidence, unlike measure textures.
    @param camera_id : Id of the camera instance.
    @param image_ptr : Pointer to the image texture.
    @param type : Image type (left RGB, right depth map, etc). See \ref SL_VIEW.
    @param  mem : Whether the image should be on CPU or GPU memory (\ref SL_MEM).
    @param width : Width of the texture in pixel.
    @param height : Height of the texture in pixel.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if the retrieve succeeded.
     */
    public static native int sl_retrieve_image(int camera_id, Pointer image_ptr, @Cast("SL_VIEW") int type, @Cast("SL_MEM") int mem, int width, int height);

    /**
    \brief Convert Image format from Unsigned char to Signed char, designed for Unreal Engine pipeline, works on GPU memory.
    @param image_in : input image to convert
    @param image_signed : output image to converted
    @param stream : a cuda stream to put the compute to (def. 0)
    \note If the Output Mat does not satisfies the requirements, it is freed and re-allocated.
    */
    public static native int sl_convert_image(Pointer image_in_ptr, Pointer image_signed_ptr, CUstream_st stream);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Streaming Sender //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Creates a streaming pipeline.
    @param camera_id : Id of the camera instance.
    @param codec : defines the codec used for streaming (see \ref SL_STREAMING_CODEC).
    @param bitrate : defines the streaming bitrate in Kbits/s.
    @param port : Defines the port used for streaming.
    @param gop_size : Defines the gop size in number of frames.
    @param adaptative_bitrate : Enable/disable adaptive bitrate.
    @param chunk_size : Defines a single chunk size.
    @param target_framrate : Defines the target framerate for the streaming output.
    @return An \ref SL_ERROR_CODE that defines if the stream was started.
    \note Available range for <b>bitrate</b>: [1000 - 60000]
    | STREAMING_CODEC  | Resolution   | FPS   | bitrate (kbps) |
    |------------------|--------------|-------|----------------|
    | H264             |  HD2K        |   15  |     8500       |
    | H264             |  HD1080      |   30  |    12500       |
    | H264             |  HD720       |   60  |     7000       |
    | H265             |  HD2K        |   15  |     7000       |
    | H265             |  HD1080      |   30  |    11000       |
    | H265             |  HD720       |   60  |     6000       |
     */
    public static native int sl_enable_streaming(int camera_id, @Cast("SL_STREAMING_CODEC") int codec, @Cast("unsigned int") int bitrate, @Cast("unsigned short") short port, int gop_size, int adaptative_bitrate, int chunk_size, int target_framerate);

    /**
    \brief Disables the streaming initiated by \ref sl_enable_streaming().
    @param camera_id : Id of the camera instance.
     */
    public static native void sl_disable_streaming(int camera_id);
    /**
    \brief Tells if the streaming is running.
    @param camera_id : Id of the camera instance.
    @return Is the streaming running successfully.
     */
    public static native int sl_is_streaming_enabled(int camera_id);

    /**
    \brief Returns the \ref SL_StreamingParameters used.
    
    It corresponds to the structure given as argument to the \ref sl_enable_streaming() function.
    @return \ref SL_StreamingParameters containing the parameters used for streaming initialization.
     */
    public static native SL_StreamingParameters sl_get_streaming_parameters(int camera_id);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Save to File Utils ////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Writes the image into a file defined by its extension.
    @param camera_id : id of the camera instance.
    @param view : View of the image (SL_VIEW).
    @param file_name : file path including the name and extension.
    @return SUCCESS if the image was successfuly saved.
     */
    public static native int sl_save_current_image(int camera_id, @Cast("SL_VIEW") int view, @Cast("const char*") BytePointer file_name);
    public static native int sl_save_current_image(int camera_id, @Cast("SL_VIEW") int view, String file_name);
    /**
    \brief Writes the depth map into a file defined by its extension.
    @param camera_id : id of the camera instance.
    @param side : side of the image (0 = left, 1 = right).
    @param file_name : file path including the name and extension.
    @return SUCCESS if the depth was successfuly saved.
     */
    public static native int sl_save_current_depth(int camera_id, @Cast("SL_SIDE") int side, @Cast("const char*") BytePointer file_name);
    public static native int sl_save_current_depth(int camera_id, @Cast("SL_SIDE") int side, String file_name);
    /**
    \brief Writes the point cloud into a file defined by its extension.
    @param camera_id : id of the camera instance.
    @param side : side of the pc (0 = left, 1 = right).
    @param file_name : file path including the name and extension.
    @return SUCCESS if the point cloud was successfuly saved.
     */
    public static native int sl_save_current_point_cloud(int camera_id, @Cast("SL_SIDE") int side, @Cast("const char*") BytePointer file_name);
    public static native int sl_save_current_point_cloud(int camera_id, @Cast("SL_SIDE") int side, String file_name);



// #if WITH_OBJECT_DETECTION

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// Object Detection //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

     /**
        \brief Check if a corresponding optimized engine is found for the requested Model based on your rig configuration.
        @param model : AI model to check.
        @param gpu_id : ID of the gpu.
        @return The status of the given model for the specified GPU.
    */
    public static native SL_AI_Model_status sl_check_AI_model_status(@Cast("SL_AI_MODELS") int model, int gpu_id);

    /**
    \brief Optimize the requested model, possible download if the model is not present on the host.
    @param model : AI model to optimize.
    @param gpu_id : ID of the gpu to optimize on.
    @return SUCCESS if the model is well optimized.
    */
    public static native int sl_optimize_AI_model(@Cast("SL_AI_MODELS") int model, int gpu_id);

    /**
    \brief Initializes and starts object detection module.
    
    The object detection module currently supports multiple class of objects with the \ref SL_OBJECT_DETECTION_MODEL "SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX"
    or \ref SL_OBJECT_DETECTION_MODEL "SL_OBJECT_DETECTION_MODEL_MULTI_CLASS_BOX_ACCURATE".
    \n The full list of detectable objects is available through \ref SL_OBJECT_CLASS and \ref SL_OBJECT_SUBCLASS.
    <p>
    \note - <b>This Deep Learning detection module is not available for \ref MODEL "MODEL::ZED" cameras (ZED first generation).</b>.
    \note - This feature uses AI to locate objects and requires a powerful GPU. A GPU with at least 3GB of memory is recommended.
    <p>
    Detected objects can be retrieved using the \ref sl_retrieve_objects() function.
    @param camera_id : Id of the camera instance.
    @param object_detection_parameters : A structure containing all the specific parameters for the object detection. Default: a preset of \ref SL_ObjectDetectionParameters.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_CORRUPTED_SDK_INSTALLATION" if the AI model is missing or corrupted. In this case, the SDK needs to be reinstalled.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CAMERA" if the camera used does not have a IMU (\ref SL_MODEL "SL_MODEL_ZED").
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct (not \ref SL_MODEL "SL_MODEL_ZED") but the IMU is missing. It probably happens because \ref SL_InitParameters.sensors_required was set to false and that IMU has not been found.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_CALL" if one of the <b>object_detection_parameters</b> parameter is not compatible with other modules parameters (for example, <b>depth_mode</b> has been set to \ref SL_DEPTH_MODE "SL_DEPTH_MODE_NONE").
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
    <p>
    \note The IMU gives the gravity vector that helps in the 3D box localization.
     */
    public static native int sl_enable_object_detection(int camera_id, SL_ObjectDetectionParameters object_detection_parameters);

    /**
    \brief Returns the \ref SL_ObjectDetectionParameters used.
    
    It corresponds to the structure given as argument to the \ref sl_enable_object_detection() function.
    @param camera_id : Id of the camera instance.
    @return \ref SL_ObjectDetectionParameters containing the parameters used for object detection initialization.
     */
    public static native SL_ObjectDetectionParameters sl_get_object_detection_parameters(int camera_id);


    /**
    \brief Disables the Object Detection process.
    <p>
    The object detection module immediately stops and frees its memory allocations.
    @param camera_id : Id of the camera instance.
    @param instance_id : Id of the object detection instance. Used when multiple instances of the object detection module are enabled at the same time.
    @param force_disable_all_instances : Should disable all instances of the object detection module or just <b>instance_id</b>.
     */
    public static native void sl_disable_object_detection(int camera_id, @Cast("unsigned int") int instance_id, @Cast("bool") boolean force_disable_all_instances);

    /**
    \brief Initializes and starts the Deep Learning Body Tracking module.
    
    The body tracking module currently supports multiple classes of human skeleton detection with the \ref SL_BODY_TRACKING_MODEL "SL_BODY_TRACKING_MODEL_HUMAN_BODY_FAST",
    \ref SL_BODY_TRACKING_MODEL "SL_BODY_TRACKING_MODEL_HUMAN_BODY_MEDIUM" or \ref SL_BODY_TRACKING_MODEL "SL_BODY_TRACKING_MODEL_HUMAN_BODY_ACCURATE".
    \n This model only detects humans but provides a full skeleton map for each person.
    <p>
    \note - <b>This Deep Learning detection module is not available for \ref MODEL "MODEL::ZED" cameras (ZED first generation).</b>.
    \note - This feature uses AI to locate objects and requires a powerful GPU. A GPU with at least 3GB of memory is recommended.
    <p>
    Detected objects can be retrieved using the \ref sl_retrieve_bodies() function.
    @param camera_id : Id of the camera instance.
    @param body_tracking_parameters : A structure containing all the specific parameters for the body tracking. Default: a preset of \ref SL_BodyTrackingParameters.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_CORRUPTED_SDK_INSTALLATION" if the AI model is missing or corrupted. In this case, the SDK needs to be reinstalled.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CAMERA" if the camera used does not have a IMU (\ref SL_MODEL "SL_MODEL_ZED").
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_MOTION_SENSORS_REQUIRED" if the camera model is correct (not \ref SL_MODEL "SL_MODEL_ZED") but the IMU is missing. It probably happens because \ref SL_InitParameters.sensors_required was set to false and that IMU has not been found.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_INVALID_FUNCTION_CALL" if one of the <b>object_detection_parameters</b> parameter is not compatible with other modules parameters (for example, <b>depth_mode</b> has been set to \ref SL_DEPTH_MODE "SL_DEPTH_MODE_NONE").
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
    <p>
    \note The IMU gives the gravity vector that helps in the 3D box localization.
     */
    public static native int sl_enable_body_tracking(int camera_id, SL_BodyTrackingParameters body_tracking_parameters);

    /**
    \brief Returns the \ref SL_BodyTrackingParameters used.
    <p>
    It corresponds to the structure given as argument to the \ref sl_enable_body_tracking() function.
    @param camera_id : Id of the camera instance.
    @return \ref SL_BodyTrackingParameters containing the parameters used for body tracking initialization.
     */
    public static native SL_BodyTrackingParameters sl_get_body_tracking_parameters(int camera_id);

    /**
    \brief Disables the body tracking process.
    <p>
    The body tracking module immediately stops and frees its memory allocations.
    @param camera_id : Id of the camera instance.
    @param instance_id : Id of the body tracking instance. Used when multiple instances of the body tracking module are enabled at the same time.
    @param force_disable_all_instances : Should disable all instances of the tracking module module or just <b>instance_id</b>.
     */
    public static native void sl_disable_body_tracking(int camera_id, @Cast("unsigned int") int instance_id, @Cast("bool") boolean force_disable_all_instances);

    /**
    \brief Generate a UUID like unique id to help identify and track AI detections.
    @param uuid : Unique ID generated.
    @return Size of the unique ID generated.
     */
    public static native int sl_generate_unique_id(@Cast("char*") BytePointer uuid);
    public static native int sl_generate_unique_id(@Cast("char*") ByteBuffer uuid);
    public static native int sl_generate_unique_id(@Cast("char*") byte[] uuid);

    /**
    \brief Feed the 3D Object tracking function with your own 2D bounding boxes from your own detection algorithm.
    @param camera_id : Id of the camera instance.
    @param objects_in : 2D detections from custom detection algorithm.
    @param nb_objects : Number of custom objects (size of the object_in array).
    \note The detection should be done on the current grabbed left image as the internal process will use all current available data to extract 3D informations and perform object tracking.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
   */
    public static native int sl_ingest_custom_box_objects(int camera_id, int nb_objects, SL_CustomBoxObjectData objects_in);

    /**
    \brief Retrieve objects detected by the object detection module.
    @param camera_id : Id of the camera instance.
    @param objects : The detected objects will be saved into this object. If the object already contains data from a previous detection, it will be updated, keeping a unique ID for the same person.
    @param object_detection_runtime_parameters : Object detection runtime settings, can be changed at each detection. In async mode, the parameters update is applied on the next iteration.
    @param instance_id : Id of the object detection instance. Used when multiple instances of the object detection module are enabled at the same time.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_retrieve_objects(int camera_id, SL_ObjectDetectionRuntimeParameters object_detection_runtime_parameters, SL_Objects objects, @Cast("unsigned int") int instance_id);

    /**
    \brief Retrieve bodies detected by the body tracking module.
    @param camera_id : id of the camera instance.
    @param bodies : The detected bodies will be saved into this object. If the object already contains data from a previous detection, it will be updated, keeping a unique ID for the same person.
    @param body_tracking_runtime_parameters : Body Tracking runtime settings, can be changed at each detection. In async mode, the parameters update is applied on the next iteration.
    @param instance_id : Id of the object detection instance. Used when multiple instances of the object detection module are enabled at the same time.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_retrieve_bodies(int camera_id, SL_BodyTrackingRuntimeParameters body_tracking_runtime_parameters, SL_Bodies bodies, @Cast("unsigned int") int instance_id);


    /**
    \brief Updates the internal batch of detected objects.
    @param camera_id : Id of the camera instance.
    @param nb_batches : [Out] Number of batches.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_update_objects_batch(int camera_id, IntPointer nb_batches);
    public static native int sl_update_objects_batch(int camera_id, IntBuffer nb_batches);
    public static native int sl_update_objects_batch(int camera_id, int[] nb_batches);

    /**
    \brief Gets a batch of detected objects.
    \note Need to be called after \ref sl_update_objects_batch().
    @param camera_id : Id of the camera instance.
    @param objs_batch : Structure containing  all the specific data of the object batch module
    @param index : Desired index in the trajectories vector.
    @return \ref SL_ERROR_CODE "SL_ERROR_CODE_SUCCESS" if everything went fine, \ref SL_ERROR_CODE "SL_ERROR_CODE_FAILURE" otherwise.
     */
    public static native int sl_get_objects_batch(int camera_id, int index, SL_ObjectsBatch objs_batch);

    public static native int sl_get_objects_batch_csharp(int camera_id, int index, IntPointer nb_data, IntPointer id, IntPointer label, IntPointer sublabel, IntPointer tracking_state,
            SL_Vector3 positions, @Cast("float(*)[6]") FloatPointer position_covariances, SL_Vector3 velocities, @Cast("unsigned long long*") LongPointer timestamps,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 bounding_boxes, FloatPointer confidences, IntPointer action_states,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 head_bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 head_bounding_boxes,
            SL_Vector3 head_positions);
    public static native int sl_get_objects_batch_csharp(int camera_id, int index, IntBuffer nb_data, IntBuffer id, IntBuffer label, IntBuffer sublabel, IntBuffer tracking_state,
            SL_Vector3 positions, @Cast("float(*)[6]") FloatBuffer position_covariances, SL_Vector3 velocities, @Cast("unsigned long long*") LongBuffer timestamps,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 bounding_boxes, FloatBuffer confidences, IntBuffer action_states,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 head_bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 head_bounding_boxes,
            SL_Vector3 head_positions);
    public static native int sl_get_objects_batch_csharp(int camera_id, int index, int[] nb_data, int[] id, int[] label, int[] sublabel, int[] tracking_state,
            SL_Vector3 positions, @Cast("float(*)[6]") float[] position_covariances, SL_Vector3 velocities, @Cast("unsigned long long*") long[] timestamps,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 bounding_boxes, float[] confidences, int[] action_states,
            @Cast("SL_Vector2(*)[4]") SL_Vector2 head_bounding_boxes_2d, @Cast("SL_Vector3(*)[8]") SL_Vector3 head_bounding_boxes,
            SL_Vector3 head_positions);

// #if 0


// #endif
// #endif
// #ifdef __cplusplus
// #endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////// MULTI CAMERA API //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// #ifdef __cplusplus
// #endif
    
    /** \brief FusionHandler initialisation. Initializes memory/generic datas
    * @param params [in] : structure containing all init parameters for the fusion API
    * @return SL_FUSION_ERROR_CODE
    */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_init(SL_InitFusionParameters params);
    
    /** \brief process the fusion.
    * @return SL_FUSION_ERROR_CODE
    */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_process();

    /*
    * \brief adds a camera to the multi camera handler
    * \param [in] uuid : unique ID that is associated with the camera for easy access.
    * \param [in] params : communications parameters
    * \param [in] pose_translation : position of the camera
    * \param [in] pose_rotation : orientation of the camera
    * \return SL_FUSION_ERROR_CODE
    * */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_subscribe(SL_CameraIdentifier uuid, SL_CommunicationParameters params, SL_Vector3 pose_translation, SL_Quaternion pose_rotation);

    /**
     * \brief Returns the current sl_VIEW_LEFT of the specified camera, the data is synchronized.
     * @param mat: the CPU BGRA image of the requested camera.
     * @param uuid: the requested camera identifier.
     * @param width: the requested width of the output image, can be lower or equal (default) to the original image width. 
     * @param height: the requested height of the output image, can be lower or equal (default) to the original image height.
     * @return \ref FUSION_ERROR_CODE "SUCCESS" if it goes as it should, otherwise it returns an FUSION_ERROR_CODE.
     * \note Only the Left BGRA image is available.
     */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_retrieve_image(Pointer mat, SL_CameraIdentifier uuid, int width, int height);

    /**
     * \brief Returns the current measure of the specified camera, the data is synchronized.
     * @param mat: the CPU data of the requested camera.
     * @param uuid: the requested camera identifier.
     * @param measure: the requested measure type, by default DEPTH (F32_C1)
     * @param width: the requested width of the output image, can be lower or equal (default) to the original image width.
     * @param height: the requested height of the output image, can be lower or equal (default) to the original image height.
     * @return \ref FUSION_ERROR_CODE "SUCCESS" if it goes as it should, otherwise it returns an FUSION_ERROR_CODE.
     * \note Only MEASURE: DEPTH, XYZ, XYZRGBA, XYZBGRA, XYZARGB, XYZABGR, DEPTH_U16_MM are available.
     */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_retrieve_measure(Pointer mat, SL_CameraIdentifier uuid, @Cast("SL_MEASURE") int measure, int width, int height);

    /**
     * \brief Remove the specified camera from data provider.
     * @param uuid: The requested camera identifier.
     * @return \ref SL_FUSION_ERROR_CODE "SUCCESS" if it goes as it should, otherwise it returns an SL_FUSION_ERROR_CODE.
     */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_unsubscribe(SL_CameraIdentifier uuid);

    /*
    * \brief update the pose of the camera in the fusion coordinate space
    * \param [in] uuid : unique ID that is associated with the camera for easy access.
    * \param [in] pose_translation : new position of the camera
    * \param [in] pose_rotation : new orientation of the camera
    * \return SL_FUSION_ERROR_CODE
    * */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_update_pose(SL_CameraIdentifier uuid, SL_Vector3 pose_translation, SL_Quaternion pose_rotation);
    
    /*
    * \brief Returns the state of a connected data sender.
    * \param [in] uuid : Identifier of the camera.
    * \return SL_SENDER_ERROR_CODE : State of the sender 
    * */
    public static native @Cast("SL_SENDER_ERROR_CODE") int sl_fusion_get_sender_state(SL_CameraIdentifier uuid);

    /**
    \brief Read a Configuration JSON file to configure a fusion process.
    @param json_config_filename : The name of the JSON file containing the configuration
    @param coord_sys : The COORDINATE_SYSTEM in which you want the World Pose to be in.
    @param unit : The UNIT in which you want the World Pose to be in.
    <p>
    @return a vector of \ref SL_FusionConfiguration for all the camera present in the file.
    \note empty if no data were found for the requested camera.
     */
    public static native void sl_fusion_read_configuration_file(@Cast("char*") BytePointer json_config_filename, @Cast("SL_COORDINATE_SYSTEM") int coord_system, @Cast("SL_UNIT") int unit, SL_FusionConfiguration configs, IntPointer nb_cameras);
    public static native void sl_fusion_read_configuration_file(@Cast("char*") ByteBuffer json_config_filename, @Cast("SL_COORDINATE_SYSTEM") int coord_system, @Cast("SL_UNIT") int unit, SL_FusionConfiguration configs, IntBuffer nb_cameras);
    public static native void sl_fusion_read_configuration_file(@Cast("char*") byte[] json_config_filename, @Cast("SL_COORDINATE_SYSTEM") int coord_system, @Cast("SL_UNIT") int unit, SL_FusionConfiguration configs, int[] nb_cameras);

    /////////////////////////////////////////////////////////////////////
    ///////////////////// Object Detection Fusion ///////////////////////
    /////////////////////////////////////////////////////////////////////

    /** \brief enables Object detection fusion module
    * @param parameters [in] defined by \ref sl::ObjectDetectionFusionParameters
    * @return SL_FUSION_ERROR_CODE
    */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_enable_body_tracking(SL_BodyTrackingFusionParameters params);

	/**
	\brief Disable the object detection module.
	 */
	public static native void sl_fusion_disable_body_tracking();

    /**
    * \brief retrieves a list of bodies (in SL_Bodies class type) seen by all cameras and merged as if it was seen by a single super-camera.
    *\note Internal calls retrieveObjects() for all listed cameras, then merged into a single SL_Bodies
    * @param bodies [out] : list of objects seen by all available cameras
    * \note Only the 3d informations is available in the returned object.
    * @return SL_FUSION_ERROR_CODE
    */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_retrieve_bodies(SL_Bodies bodies, SL_BodyTrackingFusionRuntimeParameters rt, @ByVal SL_CameraIdentifier uuid);

    /**
     * \brief get the stats of a given camera in the Fusion API side
     * It can be the received FPS, drop frame, latency, etc
     * @param metrics : structure containing all the metrics available
     * @return SL_FUSION_ERROR_CODE
     */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_get_process_metrics(SL_FusionMetrics metrics);


    /////////////////////////////////////////////////////////////////////
    ///////////////////// Positional tracking  //////////////////////////
    /////////////////////////////////////////////////////////////////////

    /**
    * \brief enable positional tracking fusion.
    * \note note that for the alpha version of the API, the positional tracking fusion doesn't support the area memory feature
    *
    * @return SL_FUSION_ERROR_CODE
    */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_enable_positional_tracking(SL_PositionalTrackingFusionParameters params);

    /**
     * \brief Get the Fused Position of the camera system
     *
     * @param camera_pose will contain the camera pose in world position (world position is given by the calibration of the cameras system)
     * @param reference_frame defines the reference from which you want the pose to be expressed. Default : \ref REFERENCE_FRAME "REFERENCE_FRAME::WORLD".
     * @param uuid Camera identifier
     * @return POSITIONAL_TRACKING_STATE is the current state of the tracking process
     */
    public static native @Cast("SL_POSITIONAL_TRACKING_STATE") int sl_fusion_get_position(SL_PoseData pose, @Cast("SL_REFERENCE_FRAME") int reference_frame, @Cast("SL_UNIT") int unit,
                                                               SL_CameraIdentifier uuid, @Cast("SL_POSITION_TYPE") int retrieve_type);


    /**
     * \brief Get the current status of fused position.
     * @return SL_FusedPositionalTrackingStatus is the current status of the tracking process.
     */
    public static native SL_FusedPositionalTrackingStatus sl_fusion_get_fused_positional_tracking_status();

    /**
     * \brief disable the positional tracking
     */
    public static native void sl_fusion_disable_positional_tracking();

    /////////////////////////////////////////////////////////////////////
    /////////////////////////// GNSS Fusion /////////////////////////////
    /////////////////////////////////////////////////////////////////////

    /**
     * \brief Add GNSS that will be used by fusion for computing fused pose.
     * @param out [in]: the current GNSS data
     * @param radian [in] : true if the gnssdata is set in radian
     */
    public static native @Cast("SL_FUSION_ERROR_CODE") int sl_fusion_ingest_gnss_data(SL_GNSSData gnss_data, @Cast("bool") boolean radian);

    /**
     * \brief returns the current GNSS data
     * @param out [out]: the current GNSS data
     * @param radian [in] : true if the gnss data is set in radian
     * @return POSITIONAL_TRACKING_STATE is the current state of the tracking process
     */
    public static native @Cast("SL_POSITIONAL_TRACKING_STATE") int sl_fusion_get_current_gnss_data(SL_GNSSData data, @Cast("bool") boolean radian);

    /**
     * \brief returns the current GeoPose
     * @param pose [out]: the current GeoPose
     * @param radian [in] : true if the geopose is set in radian.
     * @return SL_GNSS_FUSION_STATUS is the current state of the tracking process
     */
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_get_geo_pose(SL_GeoPose pose, @Cast("bool") boolean radian);

    /**
     * \brief Convert latitude / longitude into position in sl::Fusion coordinate system.
     * @param in: the current GeoPose
     * @param out [out]: the current Pose
     * @param radian [in] : true if the geopose is set in radian.
     * @return SL_GNSS_FUSION_STATUS is the current state of the tracking process
     */
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_geo_to_camera(SL_LatLng in, SL_PoseData out, @Cast("bool") boolean radian);

    /**
     * \brief returns the current GeoPose
     * @param pose [out]: the current GeoPose
     * @param radian [in] : true if the geopose is set in radian.
     * @return SL_GNSS_FUSION_STATUS is the current state of the tracking process
     */
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_camera_to_geo(SL_PoseData in, SL_GeoPose out, @Cast("bool") boolean radian);

    /**
     * \brief returns the current timestamp
     * @return the current timestamp in nanoseconds.
     */
    public static native @Cast("unsigned long long") long sl_fusion_get_current_timestamp();

    /**
     * \brief Get the current calibration uncertainty defined during calibration process
     *
     * @param yaw_std [out] yaw uncertainty
     * @param x_std [out] position uncertainty
     * @return SL_GNSS_FUSION_STATUS representing current initialisation status
     */
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_get_current_gnss_calibration_std(FloatPointer yaw_std, SL_Vector3 position_std);
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_get_current_gnss_calibration_std(FloatBuffer yaw_std, SL_Vector3 position_std);
    public static native @Cast("SL_GNSS_FUSION_STATUS") int sl_fusion_get_current_gnss_calibration_std(float[] yaw_std, SL_Vector3 position_std);

    /**
     * \brief Get the calibration found between VIO and GNSS
     * @return sl::Transform transform containing calibration found between VIO and GNSS
     */
    public static native void sl_fusion_get_geo_tracking_calibration(SL_Vector3 translation, SL_Quaternion rotation);

	/**
	\brief Close Multi Camera instance.
	 */
	public static native void sl_fusion_close();

// #ifdef __cplusplus
// #endif



// #ifdef __cplusplus
// #endif

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////// Mat ///////////////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
    \brief Creates a matrix with the given resolution.
    @param width : Width of the new matrix.
    @param height : Height of the new matrix.
    @param type : Data type and number of channels the matrix will hold (see \ref SL_MAT_TYPE).
    @param mem : Whether the matrix should be stored on CPU or GPU memory (\ref SL_MEM).
    @return Pointer of the matrix.
    */
    public static native Pointer sl_mat_create_new(int width, int height, @Cast("SL_MAT_TYPE") int type, @Cast("SL_MEM") int mem);
    /**
    \brief Creates an empty matrix.
    @return Pointer of the empty matrix.
     */
    public static native Pointer sl_mat_create_new_empty();
    /**
    \brief Returns whether the matrix is initialized or not.
    @param ptr : Pointer of the matrix.
    @return True if the matrix has been initialized.
     */
    public static native @Cast("bool") boolean sl_mat_is_init(Pointer ptr);
    /**
    \brief Frees the memory of the matrix.
    @param ptr : Pointer of the matrix to free.
    @param mem : Specifies which memory you wish to free. Default: \ref SL_MEM_CPU
     */
    public static native void sl_mat_free(Pointer ptr, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the information about the matrix into a string.
    @param ptr : Pointer of the matrix to get information from.
    @param buffer : Buffer providing matrix information.
     */
    public static native void sl_mat_get_infos(Pointer ptr, @Cast("char*") BytePointer buffer);
    public static native void sl_mat_get_infos(Pointer ptr, @Cast("char*") ByteBuffer buffer);
    public static native void sl_mat_get_infos(Pointer ptr, @Cast("char*") byte[] buffer);

    // GET values
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C1.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_uchar(Pointer ptr, int col, int row, @Cast("unsigned char*") BytePointer value, @Cast("SL_MEM") int mem);
    public static native int sl_mat_get_value_uchar(Pointer ptr, int col, int row, @Cast("unsigned char*") ByteBuffer value, @Cast("SL_MEM") int mem);
    public static native int sl_mat_get_value_uchar(Pointer ptr, int col, int row, @Cast("unsigned char*") byte[] value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C2.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_uchar2(Pointer ptr, int col, int row, SL_Uchar2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C3.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_uchar3(Pointer ptr, int col, int row, SL_Uchar3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C4.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_uchar4(Pointer ptr, int col, int row, SL_Uchar4 value, @Cast("SL_MEM") int mem);

    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C1.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_float(Pointer ptr, int col, int row, FloatPointer value, @Cast("SL_MEM") int mem);
    public static native int sl_mat_get_value_float(Pointer ptr, int col, int row, FloatBuffer value, @Cast("SL_MEM") int mem);
    public static native int sl_mat_get_value_float(Pointer ptr, int col, int row, float[] value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C2.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_float2(Pointer ptr, int col, int row, SL_Vector2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C3.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_float3(Pointer ptr, int col, int row, SL_Vector3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the value of a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C4.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to get the value from.
    @param row : Row of the point to get the value from.
    @param value[Out] : Variable to store the value to get.
    @param mem : Which memory should be read.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_get_value_float4(Pointer ptr, int col, int row, SL_Vector4 value, @Cast("SL_MEM") int mem);

    // SET VALUE
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C1.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_uchar(Pointer ptr, int col, int row, @Cast("unsigned char") byte value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C2.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_uchar2(Pointer ptr, int col, int row, @ByVal SL_Uchar2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C3.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_uchar3(Pointer ptr, int col, int row, @ByVal SL_Uchar3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_U8_C4.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_uchar4(Pointer ptr, int col, int row, @ByVal SL_Uchar4 value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C1.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_float(Pointer ptr, int col, int row, float value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C2.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_float2(Pointer ptr, int col, int row, @ByVal SL_Vector2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C3.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_float3(Pointer ptr, int col, int row, @ByVal SL_Vector3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Sets a value to a specific point in the matrix of type \ref SL_MAT_TYPE_F32_C4.
    @param ptr : Pointer of the matrix.
    @param col : Column of the point to set the value.
    @param row : Row of the point to set the value.
    @param value : Value to be set.
    @param mem : Which memory will be updated.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_value_float4(Pointer ptr, int col, int row, @ByVal SL_Vector4 value, @Cast("SL_MEM") int mem);

    //SET TO
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_U8_C1 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_uchar(Pointer ptr, @Cast("unsigned char") byte value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_U8_C2 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_uchar2(Pointer ptr, @ByVal SL_Uchar2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_U8_C3 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_uchar3(Pointer ptr, @ByVal SL_Uchar3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_U8_C4 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_uchar4(Pointer ptr, @ByVal SL_Uchar4 value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_F32_C1 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_float(Pointer ptr, float value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_F32_C2 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_float2(Pointer ptr, @ByVal SL_Vector2 value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_F32_C3 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_float3(Pointer ptr, @ByVal SL_Vector3 value, @Cast("SL_MEM") int mem);
    /**
    \brief Fills the matrix of type \ref SL_MAT_TYPE_F32_C4 with the given value.
    @param ptr : Pointer of the matrix.
    @param value : Value with which to fill the matrix.
    @param mem : Which buffer to fill.
    @return \ref SL_ERROR_CODE (as an integer) indicating if the get was successful, or why it wasn't.
     */
    public static native int sl_mat_set_to_float4(Pointer ptr, @ByVal SL_Vector4 value, @Cast("SL_MEM") int mem);

    /**
    \brief Copies data from the GPU to the CPU, if possible.
    @param ptr : Pointer of the matrix.
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_update_cpu_from_gpu(Pointer ptr);
    /**
    \brief Copies data from the CPU to the GPU, if possible.
    @param ptr : Pointer of the matrix.
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_update_gpu_from_cpu(Pointer ptr);
    /**
    \brief Copies data from this matrix to another matrix (deep copy).
    @param ptr : Pointer of the source matrix.
    @param ptr_dest : Pointer of the destination matrix.
    @param cpy_type : Specifies the memory that will be used for the copy (see \ref SL_COPY_TYPE).
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_copy_to(Pointer ptr, Pointer ptr_dest, @Cast("SL_COPY_TYPE") int cpy_type);

    /**
    \brief Reads an image from a file.
    
    Supports .png and .jpeg. Only works if matrix has access to \ref SL_MEM_CPU.
    @param ptr : Pointer of the matrix.
    @param file_path : Path of the file to read from (including the name and extension).
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_read(Pointer ptr, @Cast("const char*") BytePointer file_path);
    public static native int sl_mat_read(Pointer ptr, String file_path);
    /**
    \brief Writes the Mat into a file as an image. Only works if Mat has access to MEM_CPU.
    @param ptr : Pointer of the matrix.
    @param file_path : Path of the file to write (including the name and extension).
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_write(Pointer ptr, @Cast("const char*") BytePointer file_path);
    public static native int sl_mat_write(Pointer ptr, String file_path);
    /**
    \brief Returns the width of the matrix.
    @param ptr : Pointer of the matrix.
    @return Width of the matrix in pixels.
     */
    public static native int sl_mat_get_width(Pointer ptr);
    /**
    \brief Returns the height of the matrix.
    @param ptr : Pointer of the matrix.
    @return Height of the matrix in pixels.
     */
    public static native int sl_mat_get_height(Pointer ptr);
    /**
    \brief Returns the number of values stored in one pixel.
    @param ptr : Pointer of the matrix.
    @return Number of values in a pixel.
     */
    public static native int sl_mat_get_channels(Pointer ptr);
    /**
    \brief Gets the type of memory (CPU and/or GPU).
    @param ptr : Pointer of the matrix.
    @return Type of allocated memory (\ref SL_MEM).
     */
    public static native int sl_mat_get_memory_type(Pointer ptr);

    /**
    \brief Returns the format of the matrix.
    @param ptr : Pointer of the matrix.
    @return The memory type (\ref SL_MAT_TYPE).
     */
    public static native int sl_mat_get_data_type(Pointer ptr);
    /**
    \brief Returns the size of one pixel in bytes.
    @param ptr : Pointer of the matrix.
    @return Size of a pixel in bytes.
     */
    public static native int sl_mat_get_pixel_bytes(Pointer ptr);
    /**
    \brief Returns the memory step in number of elements (size in one pixel row).
    @param ptr : Pointer of the matrix.
    @param mem : Specifies whether you want \ref SL_MEM_CPU or \ref SL_MEM_GPU step.
    @return The step in number of elements.
     */
    public static native int sl_mat_get_step(Pointer ptr, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the memory step in bytes (size of one pixel row).
    @param ptr : Pointer of the matrix.
    @param mem : Specifies whether you want \ref SL_MEM_CPU or \ref SL_MEM_GPU step.
    @return The step in bytes of the specified memory.
     */
    public static native int sl_mat_get_step_bytes(Pointer ptr, @Cast("SL_MEM") int mem);
    /**
    \brief Returns the size of a row in bytes.
    @param ptr : Pointer of the matrix.
    @return Size of a row in bytes.
     */
    public static native int sl_mat_get_width_bytes(Pointer ptr);
    /**
    \brief Returns whether the matrix is the owner of the memory it accesses.
    @return true if the matrix is owning its memory, else false.
     */
    public static native @Cast("bool") boolean sl_mat_is_memory_owner(Pointer ptr);
    /**
    \brief Returns the resolution (width and height) of the matrix.
    @param ptr : Pointer of the matrix.
    @return \ref SL_Resolution of the matrix in pixels.
     */
    public static native @ByVal SL_Resolution sl_mat_get_resolution(Pointer ptr);
    /**
    \brief Allocates memory for the matrix.
    @param ptr : Pointer of the matrix.
    @param width : Width of the matrix in pixels.
    @param height : Height of the matrix in pixels.
    @param type : Type of the matrix (\ref SL_MAT_TYPE_F32_C1, \ref SL_MAT_TYPE_U8_C4, etc.).
    @param mem : Where the buffer will be stored.
     */
    public static native void sl_mat_alloc(Pointer ptr, int width, int height, @Cast("SL_MAT_TYPE") int type, @Cast("SL_MEM") int mem);
    /**
    \brief Copies data from another matrix into this one (deep copy).
    @param ptr : Pointer of the matrix.
    @param ptr_source : Source matrix from which to copy.
    @param copy_type : Specifies the memory that will be used for the copy (see \ref SL_COPY_TYPE).
    @param mem : Where the buffer will be stored.
    @return \ref SL_ERROR_CODE_SUCCESS if everything went well, \ref SL_ERROR_CODE_FAILURE otherwise.
     */
    public static native int sl_mat_set_from(Pointer ptr, Pointer ptr_source, @Cast("SL_COPY_TYPE") int copy_type);
    /**
    \brief Gets a pointer to the matrix.
    @param ptr : Pointer of the matrix.
    @param mem : Whether the matrix should exist on CPU or GPU memory (\ref SL_MEM).
    @return A pointer to the matrix.
     */
    public static native IntPointer sl_mat_get_ptr(Pointer ptr, @Cast("SL_MEM") int mem);
    /**
    \brief Duplicates a matrix by copying all its data into a new one (deep copy).
    @param ptr : Pointer of the matrix.
    @param ptr_source : Source matrix from which to copy.
     */
    public static native int sl_mat_clone(Pointer ptr, Pointer ptr_source);

    /**
    \brief Swaps the content of the provided matrix (only swaps the pointers, no data copy).
    @param ptr1 : Pointer of the first matrix to swap.
    @param ptr2 : Pointer of the second matrix to swap.
    */
    public static native void sl_mat_swap(Pointer ptr_1, Pointer ptr_2);

// #ifdef __cplusplus
// #endif

// #endif


}
